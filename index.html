<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- MODIFIED: Version Bump -->
    <title>Ellis Web Bell 3.49</title>
    <!-- NEW: SVG Favicon (FIXED: Removed extra quote in viewBox) -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 24 24%22 fill=%22%232563EB%22><path d=%22M12 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6-6v-5c0-3.07-1.63-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z%22/></svg>">
    <!-- Using Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Using Tone.js for web audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        // Use Century Gothic, with Questrial as a web-safe fallback
                        sans: ['Century Gothic', 'Questrial', 'sans-serif'],
                    },
                },
            },
        }
    </script>
    <!-- Updated Google Font to include Questrial as a Century Gothic fallback -->
    <link href="https://fonts.googleapis.com/css2?family=Questrial&display=swap" rel="stylesheet">
    <style>
        body {
            /* Apply the new font stack */
            font-family: 'Century Gothic', 'Questrial', 'sans-serif';
        }
        /* Styles for Admin Controls */
        /* Hide admin controls and shared delete/edit buttons by default */
        .admin-control, #combined-bell-list .delete-btn, #combined-bell-list .edit-btn {
            display: none;
        }
        /* When body has .admin-mode, show them */
        body.admin-mode .admin-control {
            display: block; 
        }
        /* Show shared delete/edit buttons in admin mode */
        body.admin-mode #combined-bell-list .delete-btn,
        body.admin-mode #combined-bell-list .edit-btn {
            display: inline-block;
        }
        /* Always show custom delete/edit buttons */
        #combined-bell-list .delete-custom-btn,
        #combined-bell-list .edit-custom-btn {
            display: inline-block;
        }

        /* NEW: Sound override button is always visible for shared bells */
        #combined-bell-list .sound-btn {
            display: inline-block;
        }
        /* Hide sound override button for custom bells (they use 'Edit') */
        #combined-bell-list .sound-custom-btn {
            display: none;
        }


        /* MODIFIED: v3.24 - Consolidated Z-Indexing */
        /* All standard modals are z-50 */
        #edit-bell-modal { z-index: 50; }
        #change-sound-modal { z-index: 50; }
        #nearby-bell-modal { z-index: 50; }
        #confirm-delete-bell-modal { z-index: 50; }
        #confirm-delete-audio-modal { z-index: 50; }
        #internal-conflict-warning-modal { z-index: 50; }
        #external-conflict-modal { z-index: 50; }
        #create-personal-schedule-modal { z-index: 50; }
        #confirm-delete-personal-modal { z-index: 50; }
        #confirm-restore-modal { z-index: 50; }
        /* NEW: v3.26 - Add rename modal to z-50 */
        #rename-personal-schedule-modal { z-index: 50; }
        
        /* Modals that appear ON TOP of other modals are z-60 */
        #confirm-linked-edit-modal { z-index: 60; }
        #internal-conflict-confirm-modal { z-index: 60; }
        /* Note: Overlays (welcome, audio) and base modals 
           (add-bell, confirm-delete) are set in HTML classes. */
        /* END v3.24 Z-Index Cleanup */

        
        /* NEW: Hide file input, style the button */
        #import-file-input, #audio-upload-input, #restore-file-input {
            display: none;
        }

        /* NEW: Hide elements that require non-anonymous auth */
        .auth-required {
            display: none;
        }
        /* When authenticated AND not anonymous, show them */
        body.authenticated.not-anonymous .auth-required {
            display: block;
        }

        /* NEW: Admin-only elements, hidden by default */
        .admin-only {
            display: none;
        }
        /* Show when in admin mode */
        body.admin-mode .admin-only {
            display: inline-flex; /* MODIFIED: Use inline-flex to work with flex properties */
        }

        /* DELETED: These rules don't work with the CDN build */
        /*
        .quick-bell-btn {
            @apply bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded-lg text-sm transition-all duration-150 shadow-md hover:shadow-lg;
        }

        .quick-bell-btn:active {
            @apply transform scale-95;
        }
        */

    </style>
</head>
<body class="bg-gray-100 text-gray-900 font-sans"> <!-- Added font-sans to apply tailwind default -->

    <!-- NEW: Auth/Welcome Overlay -->
    <div id="welcome-overlay" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-white p-10 rounded-lg shadow-xl w-full max-w-md text-center">
            <h2 class="text-3xl font-bold text-blue-700 mb-4">Welcome to the Ellis Web Bell!</h2>
            <p class="text-gray-600 mb-8">Please sign in to load and sync schedules.</p>
            <div class="space-y-4">
                <button id="google-start-btn" class="w-full flex items-center justify-center gap-2 px-6 py-3 bg-white text-gray-700 font-medium rounded-lg shadow-md border border-gray-200 hover:bg-gray-50 transition-colors">
                    <svg class="w-5 h-5" viewBox="0 0 48 48">
                        <path fill="#4285F4" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l8.28 6.42C12.92 13.9 18.06 9.5 24 9.5z"></path>
                        <path fill="#34A853" d="M46.98 24.55c0-1.57-.15-3.09-.42-4.55H24v8.51h12.8c-.57 2.73-2.2 5.08-4.79 6.69l7.38 5.71C44.97 36.3 46.98 30.8 46.98 24.55z"></path>
                        <path fill="#FBBC05" d="M10.84 28.71C10.22 26.9 9.83 24.99 9.83 23c0-1.99.39-3.9 1.01-5.71L2.56 10.8C.9 14.28 0 18.48 0 23c0 4.52.9 8.72 2.56 12.2l8.28-6.49z"></path>
                        <path fill="#EA4335" d="M24 48c5.4 0 10.32-1.62 14.34-4.38l-7.38-5.71C28.71 40.5 26.47 42.1 24 42.1c-5.94 0-11.08-4.4-12.96-10.28L2.56 38.2C6.51 46.04 14.62 48 24 48z"></path>
                        <path fill="none" d="M0 0h48v48H0z"></path>
                    </svg>
                    Sign in with Google
                </button>
                <button id="anonymous-start-btn" class="w-full px-6 py-3 bg-gray-600 text-white font-medium rounded-lg shadow-md hover:bg-gray-700 transition-colors">
                    Continue Anonymously
                </button>
            </div>
        </div>
    </div>

    <!-- NEW: Audio Start Overlay (for refresh) -->
    <div id="audio-overlay" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-40 hidden">
        <button id="start-audio-btn" class="px-8 py-4 bg-blue-600 text-white font-bold text-2xl rounded-lg shadow-lg hover:bg-blue-700 transition-colors text-center">
            <!-- MODIFIED: Default text changed, will be updated by JS -->
            Loading...
        </button>
    </div>

    <!-- NEW: Add Bell to Multiple Schedules Modal -->
    <!-- MODIFIED: v3.24 - Changed z-40 to z-50 -->
    <div id="add-bell-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 hidden">
        <form id="multi-add-bell-form" class="bg-white p-8 rounded-lg shadow-xl w-full max-w-lg">
            <h3 class="text-2xl font-medium mb-6">Add Bell to Schedules</h3>
            
            <!-- Bell Details -->
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="multi-bell-time" class="block text-sm font-medium text-gray-700">Time (HH:MM:SS)</label>
                    <input type="time" id="multi-bell-time" step="1" required class="mt-1 w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="multi-bell-name" class="block text-sm font-medium text-gray-700">Bell Name</label>
                    <input type="text" id="multi-bell-name" placeholder="e.g. 1st Period End" required class="mt-1 w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
            </div>
            <div>
                <label for="multi-bell-sound" class="block text-sm font-medium text-gray-700">Sound</label>
                <!-- MODIFIED: Sound select now uses optgroups -->
                <select id="multi-bell-sound" class="mt-1 w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <optgroup label="Default Sounds">
                        <option value="Bell">Bell</option>
                        <option value="Chime">Chime</option>
                        <option value="Beep">Beep</option>
                        <option value="Alarm">Alarm</option>
                        <!-- MODIFIED: Made Ellis Bell selected by default -->
                        <option value="ellisBell.mp3" selected>Ellis Bell</option>
                    </optgroup>
                    <optgroup label="My Sounds" id="multi-my-sounds-optgroup"></optgroup>
                    <optgroup label="Shared Sounds" id="multi-shared-sounds-optgroup"></optgroup>
                </select>
            </div>

            <!-- Schedule Checkboxes -->
            <div class="mt-6">
                <label class="block text-sm font-medium text-gray-700 mb-2">Select Schedules to Add to:</label>
                <!-- NEW: Select All/None buttons -->
                <div class="flex gap-2 mb-2">
                    <button type="button" id="multi-select-all" class="px-3 py-1 text-xs bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300">Select All</button>
                    <button type="button" id="multi-select-none" class="px-3 py-1 text-xs bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300">Select None</button>
                </div>
                <div id="multi-schedule-list-container" class="max-h-48 overflow-y-auto border border-gray-200 rounded-lg p-4 grid grid-cols-1 sm:grid-cols-2 gap-2">
                    <!-- Checkboxes will be dynamically injected here -->
                    <p class="text-gray-500">Loading schedules...</p>
                </div>
            </div>
            
            <p id="multi-add-status" class="text-blue-600 text-sm mt-4 hidden"></p>

            <div class="mt-6 flex justify-end gap-3">
                <button type="button" id="multi-add-cancel" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                <button type="submit" id="multi-add-submit" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Add Bell</button>
            </div>
        </form>
    </div>

    <!-- NEW: Edit Bell Modal (Admin) -->
    <div id="edit-bell-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 hidden">
        <form id="edit-bell-form" class="bg-white p-8 rounded-lg shadow-xl w-full max-w-lg">
            <h3 class="text-2xl font-medium mb-6">Edit Bell</h3>
            
            <!-- Bell Details -->
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="edit-bell-time" class="block text-sm font-medium text-gray-700">Time (HH:MM:SS)</label>
                    <input type="time" id="edit-bell-time" step="1" required class="mt-1 w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="edit-bell-name" class="block text-sm font-medium text-gray-700">Bell Name</label>
                    <input type="text" id="edit-bell-name" placeholder="e.g. 1st Period End" required class="mt-1 w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
            </div>
            <div>
                <label for="edit-bell-sound" class="block text-sm font-medium text-gray-700">Sound</label>
                <!-- MODIFIED: Sound select now uses optgroups -->
                <select id="edit-bell-sound" class="mt-1 w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <optgroup label="Default Sounds">
                        <option value="Bell">Bell</option>
                        <option value="Chime">Chime</option>
                        <option value="Beep">Beep</option>
                        <option value="Alarm">Alarm</option>
                        <!-- MODIFIED: Made Ellis Bell selected by default -->
                        <option value="ellisBell.mp3" selected>Ellis Bell</option>
                    </optgroup>
                    <optgroup label="My Sounds" id="edit-my-sounds-optgroup"></optgroup>
                    <optgroup label="Shared Sounds" id="edit-shared-sounds-optgroup"></optgroup>
                </select>
            </div>
            
            <p id="edit-bell-status" class="text-blue-600 text-sm mt-4 hidden"></p>

            <div class="mt-6 flex justify-end gap-3">
                <button type="button" id="edit-bell-cancel" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                <button type="submit" id="edit-bell-submit" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Save Changes</button>
            </div>
        </form>
    </div>

    <!-- **** NEW: Change Bell SOUND Modal (All Users) **** -->
    <div id="change-sound-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 hidden">
        <form id="change-sound-form" class="bg-white p-8 rounded-lg shadow-xl w-full max-w-lg">
            <h3 class="text-2xl font-medium mb-6">Change Bell Sound</h3>
            
            <!-- Bell Info (Read-only) -->
            <div class="bg-gray-100 p-4 rounded-lg mb-4">
                <p class="text-sm font-medium text-gray-700">Bell:</p>
                <p id="change-sound-bell-name" class="text-lg font-semibold text-gray-900"></p>
                <p id="change-sound-bell-time" class="text-lg font-semibold text-gray-900"></p>
            </div>

            <!-- MODIFIED: v3.19 - Sound Select + Play Button -->
            <div class="flex items-end gap-2">
                <div class="flex-grow">
                    <label for="change-sound-select" class="block text-sm font-medium text-gray-700">Sound</label>
                    <select id="change-sound-select" class="mt-1 w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <optgroup label="Default Sounds">
                            <option value="Bell">Bell</option>
                            <option value="Chime">Chime</option>
                            <option value="Beep">Beep</option>
                            <option value="Alarm">Alarm</option>
                            <option value="ellisBell.mp3" selected>Ellis Bell</option>
                        </optgroup>
                        <optgroup label="My Sounds" id="change-my-sounds-optgroup"></optgroup>
                        <optgroup label="Shared Sounds" id="change-shared-sounds-optgroup"></optgroup>
                    </select>
                </div>
                <button type="button" id="preview-change-sound" class="w-10 h-10 flex-shrink-0 flex items-center justify-center text-lg bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors" aria-label="Preview">
                    &#9654;
                </button>
            </div>
            <!-- END MODIFICATION -->

            <!-- Warning Message -->
            <div class="mt-4 p-4 bg-yellow-100 border-l-4 border-yellow-400 rounded">
                <p class="text-sm text-yellow-800">Are you sure you want to change this bell's sound? Your sound should be a brief but obvious indication of transition.</p>
            </div>
            
            <div class="mt-6 flex justify-end gap-3">
                <button type="button" id="change-sound-cancel" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                <button type="submit" id="change-sound-submit" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Save Sound</button>
            </div>
        </form>
    </div>

    <!-- NEW: Confirm Linked Edit Modal -->
    <div id="confirm-linked-edit-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-[60] hidden">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-lg">
            <h3 class="text-xl font-medium mb-4">Update Linked Schedules?</h3>
            <p class="text-gray-700 mb-4">This bell was found in other schedules. Do you want to apply your edit to them as well?</p>
            
            <p class="text-sm font-medium text-gray-700 mb-2">Schedules containing this bell:</p>
            <div id="linked-schedule-list" class="max-h-48 overflow-y-auto border border-gray-200 rounded-lg p-4 grid grid-cols-1 sm:grid-cols-2 gap-2">
                <!-- Linked schedules will be injected here -->
            </div>
            
            <p id="linked-edit-status" class="text-blue-600 text-sm mt-4 hidden"></p>

            <div class="mt-6 flex flex-col sm:flex-row justify-end gap-3">
                <button type="button" id="linked-edit-cancel" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                <button type="button" id="linked-edit-this-only" class="px-4 py-2 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700">Update This Schedule Only</button>
                <button type="button" id="linked-edit-apply" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Apply to All Selected</button>
            </div>
        </div>
    </div>


    <!-- NEW: Confirm Delete Schedule Modal -->
    <!-- MODIFIED: v3.24 - Changed z-40 to z-50 -->
    <div id="confirm-delete-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-sm">
            <h3 class="text-xl font-medium mb-4">Delete Schedule</h3>
            <p id="confirm-delete-text" class="text-gray-700 mb-6">Are you sure you want to delete this schedule? This action cannot be undone.</p>
            <div class="mt-6 flex justify-end gap-3">
                <button type="button" id="delete-cancel" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                <button type="button" id="delete-confirm" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Delete</button>
            </div>
        </div>
    </div>
    
    <!-- **** NEW: Confirm Delete BELL Modal **** -->
    <!-- This replaces the browser's `confirm()` dialog -->
    <div id="confirm-delete-bell-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-sm">
            <h3 class="text-xl font-medium mb-4">Delete Bell</h3>
            <p id="confirm-delete-bell-text" class="text-gray-700 mb-6">Are you sure you want to delete this bell?</p>
            <div class="mt-6 flex justify-end gap-3">
                <button type="button" id="delete-bell-cancel" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                <button type="button" id="delete-bell-confirm" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Delete</button>
            </div>
        </div>
    </div>

    <!-- **** NEW: Confirm Delete AUDIO Modal **** -->
    <div id="confirm-delete-audio-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-lg">
            <h3 class="text-xl font-medium mb-4">Delete Audio File</h3>
            <p id="confirm-delete-audio-text" class="text-gray-700 mb-4">Are you sure you want to delete this audio file?</p>
            
            <ul id="confirm-delete-audio-list" class="max-h-48 overflow-y-auto border border-gray-200 rounded-lg p-4 space-y-1 bg-gray-50 mb-6">
                <!-- Linked bells will be injected here -->
            </ul>
            
            <div class="mt-6 flex justify-end gap-3">
                <button type="button" id="delete-audio-cancel" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                <button type="button" id="delete-audio-confirm" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Delete Anyway</button>
            </div>
        </div>
    </div>

    <!-- **** NEW: Nearby Bell Warning Modal (Req 1 - Custom Bells ONLY) **** -->
    <div id="nearby-bell-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-lg">
            <h3 class="text-xl font-medium mb-4">Nearby Bell Detected</h3>
            <p class="text-gray-700 mb-6">A bell named "<strong id="nearby-bell-name">...</strong>" is already scheduled for <strong id="nearby-bell-time">...</strong>. This is very close to your new time.</p>
            
            <p id="nearby-bell-status" class="text-blue-600 text-sm mt-4 hidden"></p>

            <!-- Controls for Custom Bells (Req 1) -->
            <div id="nearby-bell-custom-controls" class="mt-6 flex justify-end gap-3">
                <button type="button" id="nearby-bell-cancel" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                <!-- MODIFIED: v3.25 - Text updated for clarity -->
                <button type="button" id="nearby-bell-confirm" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Confirm Action Anyway</button>
            </div>
            
            <!-- DELETED: Old Admin Controls (Req 3) -->
            <!-- This is now handled by the new v3.02 modals -->
        </div>
    </div>

    <!-- **** NEW: Scenario 1, Step 1: Internal Conflict Warning Modal **** -->
    <div id="internal-conflict-warning-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-lg">
            <h3 class="text-xl font-medium mb-4 text-yellow-800">Warning: Confusing Bell Time</h3>
            <p class="text-gray-700 mb-6">The time you selected (<strong id="internal-conflict-new-time">...</strong>) is within 60 seconds of an existing bell (<strong id="internal-conflict-existing-bell">...</strong>) in this *same* schedule. This would be very confusing for end users. We strongly suggest editing the existing bell first.</p>
            
            <div class="mt-6 flex flex-col sm:flex-row justify-end gap-3">
                <button type="button" id="internal-conflict-cancel" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                <button type="button" id="internal-conflict-edit" class="px-4 py-2 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700">Edit Existing Bell</button>
                <button type="button" id="internal-conflict-confirm" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Confirm New Bell</button>
            </div>
        </div>
    </div>

    <!-- **** NEW: Scenario 1, Step 2: Internal Conflict Final Confirmation Modal **** -->
    <div id="internal-conflict-confirm-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-60 hidden">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-lg">
            <h3 class="text-xl font-medium mb-4 text-red-700">Are you sure?</h3>
            <p class="text-gray-700 mb-6">Are you absolutely positive you want to create a new bell at <strong id="internal-conflict-final-new-time">...</strong>, just <strong id="internal-conflict-final-diff">...</strong> seconds apart from the existing <strong id="internal-conflict-final-existing">...</strong> bell?</p>
            
            <div class="mt-6 flex justify-end gap-3">
                <button type="button" id="internal-conflict-final-cancel" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                <button type="button" id="internal-conflict-final-create" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Yes, Create This Bell</button>
            </div>
        </div>
    </div>

    <!-- **** NEW: Scenario 2: External Conflict Resolution Modal **** -->
    <div id="external-conflict-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-2xl"> <!-- Increased max-w -->
            <h3 class="text-xl font-medium mb-4">Similar Bell Found in Other Schedules</h3>
            <p class="text-gray-700 mb-4">One or more other shared schedules have bells with the same name very close to your new time of <strong id="external-conflict-new-time">...</strong>. Please select how you'd like to proceed.</p>
            
            <p class="text-sm font-medium text-gray-700 mb-2">Conflicting bells (select to "Create and Match"):</p>
            <div id="external-conflict-list" class="max-h-60 overflow-y-auto border border-gray-200 rounded-lg p-4 grid grid-cols-1 sm:grid-cols-2 gap-2 mb-6 bg-gray-50">
                <!-- Conflicting bells will be injected here -->
                <p class="text-gray-500">Loading conflicts...</p>
            </div>
            
            <p id="external-conflict-status" class="text-blue-600 text-sm mt-4 mb-4 hidden"></p>

            <div class="mt-6 flex flex-col gap-3">
                <!-- Option 1: Match Existing (Disabled unless 1 is checked) -->
                <button type="button" id="external-conflict-match-existing" class="w-full px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:opacity-50" disabled>
                    Match Existing Bell Time (<span id="external-conflict-match-time">--:--</span>)
                </button>
                <!-- Option 2: Keep My Time (Always enabled) -->
                <button type="button" id="external-conflict-keep-new" class="w-full px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">
                    Keep My New Time (<span id="external-conflict-keep-time">--:--</span>) and Create a New Bell
                </button>
                <!-- Option 3: Create and Match (Disabled unless 1+ is checked) -->
                <button type="button" id="external-conflict-create-and-match" class="w-full px-4 py-2 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700 disabled:opacity-50" disabled>
                    Create a New Bell and Match Selected Bells to The New Time
                </button>
                <!-- Option 4: Cancel -->
                <button type="button" id="external-conflict-cancel" class="w-full px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 mt-2">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- MOVED: Personal Schedule Modals (v3.08) -->
    <!-- NEW: v3.03 - Create Personal Schedule Modal -->
    <div id="create-personal-schedule-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 hidden">
        <form id="create-personal-schedule-form" class="bg-white p-8 rounded-lg shadow-xl w-full max-w-lg">
            <h3 class="text-2xl font-medium mb-6">New Personal Schedule</h3>
            
            <p class="text-gray-700 mb-4">
                Base Schedule: <strong id="personal-base-schedule-name">...</strong>
            </p>
            
            <div>
                <label for="new-personal-schedule-name" class="block text-sm font-medium text-gray-700">New Schedule Name</label>
                <input type="text" id="new-personal-schedule-name" placeholder="e.g. My A-Day Schedule" required class="mt-1 w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
            
            <p id="create-personal-schedule-status" class="text-blue-600 text-sm mt-4 hidden"></p>

            <div class="mt-6 flex justify-end gap-3">
                <button type="button" id="create-personal-schedule-cancel" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                <button type="submit" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700">Create</button>
            </div>
        </form>
    </div>

    <!-- NEW: v3.03 - Confirm Delete Personal Schedule Modal -->
    <div id="confirm-delete-personal-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-sm">
            <h3 class="text-xl font-medium mb-4">Delete Personal Schedule</h3>
            <p id="confirm-delete-personal-text" class="text-gray-700 mb-6">Are you sure?</p>
            <div class="mt-6 flex justify-end gap-3">
                <button type="button" id="delete-personal-cancel" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                <button type="button" id="delete-personal-confirm" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Delete</button>
            </div>
        </div>
    </div>
    
    <!-- NEW: v3.05 - Confirm Restore Personal Schedule Modal -->
    <div id="confirm-restore-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-sm">
            <h3 class="text-xl font-medium mb-4">Overwrite Personal Schedule</h3>
            <p id="confirm-restore-text" class="text-gray-700 mb-6">Are you sure?</p>
            <div class="mt-6 flex justify-end gap-3">
                <button type="button" id="restore-cancel" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                <button type="button" id="restore-confirm" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Overwrite</button>
            </div>
        </div>
    </div>
    
    <!-- NEW: v3.26 - Rename Personal Schedule Modal -->
    <div id="rename-personal-schedule-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 hidden">
        <form id="rename-personal-schedule-form" class="bg-white p-8 rounded-lg shadow-xl w-full max-w-lg">
            <h3 class="text-2xl font-medium mb-6">Rename Personal Schedule</h3>
            
            <p class="text-gray-700 mb-4">
                Current Name: <strong id="rename-old-schedule-name">...</strong>
            </p>
            
            <div>
                <label for="rename-new-schedule-name" class="block text-sm font-medium text-gray-700">New Schedule Name</label>
                <input type="text" id="rename-new-schedule-name" placeholder="e.g. My A-Day Schedule" required class="mt-1 w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>
            
            <p id="rename-personal-schedule-status" class="text-blue-600 text-sm mt-4 hidden"></p>

            <div class="mt-6 flex justify-end gap-3">
                <button type="button" id="rename-personal-cancel" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Save Name</button>
            </div>
        </form>
    </div>
    <!-- END: Moved Modals (v3.08) -->


    <!-- Main Application -->
    <div class="container mx-auto max-w-2xl p-4 md:p-8">
        <header class="text-center mb-8">
            <!-- MODIFIED: Version Bump -->
            <h1 class="text-4xl font-bold text-blue-700">Ellis Web Bell 3.49</h1>
            <p class="text-lg text-gray-600">A real-time, synchronized bell schedule</p>
            
            <!-- MODIFIED: User info and signout button grouped -->
            <div class="mt-4 flex flex-col sm:flex-row justify-center items-center gap-4">
                <!-- NEW: User display name -->
                <p id="user-display-name" class="text-gray-700"></p>
                <button id="signout-btn" class="w-full sm:w-auto px-4 py-1 text-sm bg-gray-200 text-gray-700 font-medium rounded-lg hover:bg-gray-300 transition-colors hidden">
                    Sign Out
                </button>
            </div>
        </header>

        <!-- MODIFIED: This card now shows countdown AND current time -->
        <div class="bg-white p-6 md:p-10 rounded-xl shadow-md mb-8">
            <!-- NEW: Restructured countdown/clock -->
            <div class="text-center">
                <!-- Line 1: "The time is HH:MM:SS. There are" -->
                <div id="live-clock-sentence" class="text-2xl font-medium text-gray-600 tabular-nums">
                    Loading...
                </div>
                <!-- Line 2: "HH:MM:SS" (countdown) -->
                <div id="countdown-display" class="text-6xl md:text-8xl font-bold text-gray-800 tabular-nums my-2">
                    --:--
                </div>
                <!-- Line 3: "until XXBELLXX" -->
                <div id="next-bell-sentence" class="text-2xl font-medium text-gray-600">
                    until the next bell.
                </div>
                <!-- MODIFIED: v3.21 -> v3.22 - This line's content logic is updated -->
                <div id="next-bell-info" class="text-lg text-gray-500 mt-2">
                    <!-- JS will populate this -->
                </div>
            </div>

            <!-- Status messages remain -->
            <div class="text-center text-gray-500 text-lg mt-6"> <!-- Added more margin -->
                Status: <span id="status-message" class="font-medium text-gray-700">Initializing...</span>
            </div>

            <!-- DELETED: Old Mute Controls -->

        </div>

        <!-- **** NEW: Quick Bell Section **** -->
        <div id="quickBellControls" class="p-4 bg-white rounded-xl shadow-md mb-8 flex flex-col sm:flex-row justify-between items-center space-y-4 sm:space-y-0 sm:space-x-4">
            <div class="flex items-center space-x-3 flex-shrink-0"> <!-- ADDED flex-shrink-0 -->
                <span class="font-semibold text-gray-700">Quick Bell:</span>
                <div class="flex flex-wrap gap-2">
                    <!-- ADDED: The 'quick-bell-btn' class as a JS hook -->
                    <button data-minutes="1" class="quick-bell-btn bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded-lg text-sm transition-all duration-150 shadow-md hover:shadow-lg transform active:scale-95">1</button>
                    <button data-minutes="2" class="quick-bell-btn bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded-lg text-sm transition-all duration-150 shadow-md hover:shadow-lg transform active:scale-95">2</button>
                    <button data-minutes="3" class="quick-bell-btn bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded-lg text-sm transition-all duration-150 shadow-md hover:shadow-lg transform active:scale-95">3</button>
                    <button data-minutes="5" class="quick-bell-btn bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded-lg text-sm transition-all duration-150 shadow-md hover:shadow-lg transform active:scale-95">5</button>
                    <button data-minutes="10" class="quick-bell-btn bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded-lg text-sm transition-all duration-150 shadow-md hover:shadow-lg transform active:scale-95">10</button>
                    <button data-minutes="15" class="quick-bell-btn bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded-lg text-sm transition-all duration-150 shadow-md hover:shadow-lg transform active:scale-95">15</button>
                </div>
            </div>
            <div class="flex items-center space-x-2 flex-shrink min-w-0 w-full sm:w-auto"> <!-- ADDED flex-shrink min-w-0 w-full sm:w-auto -->
                <label for="quickBellSoundSelect" class="text-sm font-medium text-gray-700">Sound:</label>
                <!-- This select will be populated by JS to match the others -->
                <select id="quickBellSoundSelect" class="w-full truncate px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500"> <!-- REPLACED sm:w-auto WITH w-full and ADDED truncate -->
                    <optgroup label="Default Sounds">
                        <option value="Bell">Bell</option>
                        <option value="Chime">Chime</option>
                        <option value="Beep">Beep</option>
                        <option value="Alarm">Alarm</option>
                        <option value="ellisBell.mp3" selected>Ellis Bell</option>
                    </optgroup>
                    <optgroup label="My Sounds" id="quick-my-sounds-optgroup"></optgroup>
                    <optgroup label="Shared Sounds" id="quick-shared-sounds-optgroup"></optgroup>
                </select>
            </div>
        </div>
        <!-- **** END NEW: Quick Bell Section **** -->


        <!-- Combined Bell Schedule List -->
        <div>
            <!-- NEW: Mute Controls added -->
            <div class="flex justify-between items-center mb-4">
                 <h2 id="schedule-title" class="text-2xl font-semibold">Current Schedule</h2>
                 <div class="flex-shrink-0 flex gap-2">
                     <button id="mute-all-list-btn" class="px-3 py-1 text-sm bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Mute All</button>
                     <button id="unmute-all-list-btn" class="px-3 py-1 text-sm bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Unmute All</button>
                 </div>
            </div>
            <div id="combined-bell-list" class="bg-white rounded-xl shadow-md overflow-hidden mb-8">
                <!-- Bells will be injected here by JavaScript -->
                <div class="p-8 text-center text-gray-500">
                    Loading schedule...
                </div>
            </div>
        </div>

        <!-- Schedule Selector -->
        <div class="bg-white p-6 rounded-xl shadow-md mb-8">
            <div class="flex justify-between items-center mb-2">
                <!-- MODIFIED: v3.03 - Relabeled -->
                <label for="schedule-selector" class="block text-lg font-medium text-gray-700">Active Schedule</label>
                <!-- MODIFIED: Disabled by default, enabled via JS for admins -->
                <button id="admin-toggle" class="px-3 py-1 text-sm bg-gray-200 text-gray-800 rounded-full hover:bg-gray-300 transition-colors opacity-50 cursor-not-allowed" disabled title="Sign in to see admin options">
                    Toggle Admin
                </button>
            </div>
            
            <!-- NEW (FIXED): Re-inserted the missing select element -->
            <select id="schedule-selector" class="w-full mt-2 px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" disabled>
                <option value="">Loading schedules...</option>
            </select>
 
            <!-- NEW: v3.03 - Button to create personal schedule -->
            <button id="create-personal-schedule-btn" class="auth-required w-full mt-4 px-4 py-2 bg-green-600 text-white font-medium rounded-lg shadow-md hover:bg-green-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                Copy as Personal Schedule
            </button>
        </div>
        
        <!-- DELETED: v3.08 - Personal Schedule Modals were here and breaking layout -->
        <!-- DELETED: Malformed, duplicate confirm-delete-personal-modal -->


        <!-- NEW: Admin Zone for creating schedules and adding bells -->
        <div class="admin-control bg-white p-6 rounded-xl shadow-md mb-8 space-y-6">
            <h3 class="text-xl font-semibold text-gray-800 border-b pb-2">Admin Zone</h3>
            
            <!-- Create New Schedule Form -->
            <form id="create-schedule-form">
                <label for="new-schedule-name" class="block text-sm font-medium text-gray-700 mb-1">Create New Schedule</label>
                <div class="flex flex-col sm:flex-row gap-3">
                    <input type="text" id="new-schedule-name" placeholder="New Schedule Name" required class="flex-grow w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <button type="submit" class="w-full sm:w-auto px-6 py-2 bg-green-600 text-white font-medium rounded-lg shadow-md hover:bg-green-700">
                        Create
                    </button>
                </div>
            </form>

            <!-- NEW: Add Bell to THIS Schedule Form -->
            <form id="add-shared-bell-form" class="border-t pt-6">
                <label class="block text-sm font-medium text-gray-700 mb-1">Add Bell to This Schedule</label>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="shared-bell-time" class="block text-sm font-medium text-gray-700 mb-1">Time (HH:MM:SS)</label>
                        <input type="time" id="shared-bell-time" step="1" required class="w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <div>
                        <label for="shared-bell-name" class="block text-sm font-medium text-gray-700 mb-1">Bell Name</label>
                        <input type="text" id="shared-bell-name" placeholder="e.g. 1st Period Start" required class="w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                </div>
                <div class="flex flex-col sm:flex-row sm:items-end gap-4">
                    <div class="flex-grow" style="min-width: 120px;">
                        <label for="shared-bell-sound" class="block text-sm font-medium text-gray-700 mb-1">Sound</label>
                        <!-- MODIFIED: Sound select now uses optgroups -->
                        <select id="shared-bell-sound" class="w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <optgroup label="Default Sounds">
                                <option value="Bell">Bell</option>
                                <option value="Chime">Chime</option>
                                <option value="Beep">Beep</option>
                                <option value="Alarm">Alarm</option>
                                <option value="ellisBell.mp3" selected>Ellis Bell</option>
                            </optgroup>
                            <optgroup label="My Sounds" id="shared-my-sounds-optgroup"></optgroup>
                            <optgroup label="Shared Sounds" id="shared-shared-sounds-optgroup"></optgroup>
                        </select>
                    </div>
                    <!-- MODIFIED: Changed button text from "Play" to icon -->
                    <button type="button" id="preview-shared-sound" class="w-10 h-10 flex-shrink-0 flex items-center justify-center text-lg bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors" aria-label="Preview">
                        &#9654;
                    </button>
                    <button type="submit" class="w-full sm:w-auto px-6 py-2 bg-green-600 text-white font-medium rounded-lg shadow-md hover:bg-green-700 transition-colors focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">
                        Add Shared Bell
                    </button>
                </div>
                <p id="add-shared-status" class="text-blue-600 text-sm mt-3 hidden"></p>
            </form>

            <!-- Add Bell to Schedules Button -->
            <div class="border-t pt-6">
                <label class="block text-sm font-medium text-gray-700 mb-1">Add Bell to Multiple Schedules</label>
                <button type="button" id="show-add-bell-modal-btn" class="w-full px-6 py-2 bg-blue-600 text-white font-medium rounded-lg shadow-md hover:bg-blue-700">
                    Add Bell to Schedules...
                </button>
            </div>

            <!-- MOVED: Delete Selected Schedule Button -->
            <div class="border-t pt-6">
                <label class="block text-sm font-medium text-gray-700 mb-1">Delete Current Schedule</label>
                <button type="button" id="delete-schedule-btn" class="w-full px-4 py-2 bg-red-600 text-white font-medium rounded-lg shadow-md hover:bg-red-700 transition-colors">
                    Delete Selected Schedule
                </button>
            </div>

            <!-- NEW: Import/Export Section -->
            <div class="border-t pt-6 space-y-4">
                <h4 class="text-lg font-medium text-gray-800">Backup & Restore</h4>
                
                <!-- Export -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Export All Schedules</label>
                    <button type="button" id="export-schedules-btn" class="w-full px-4 py-2 bg-blue-600 text-white font-medium rounded-lg shadow-md hover:bg-blue-700 transition-colors">
                        Download Backup (JSON)
                    </button>
                </div>

                <!-- Import -->
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Import & Overwrite Schedules</label>
                    <!-- This input is hidden and triggered by the button -->
                    <input type="file" id="import-file-input" accept="application/json">
                    <button type="button" id="import-schedules-btn" class="w-full px-4 py-2 bg-gray-600 text-white font-medium rounded-lg shadow-md hover:bg-gray-700 transition-colors">
                        Upload Backup (JSON)
                    </button>
                    <p id="import-status" class="text-blue-600 text-sm mt-2 hidden"></p>
                </div>
            </div>

        </div>


        <!-- MODIFIED: Custom Bells (Local) -> Personal Bells (Cloud) v3.03 -->
        <div class="auth-required mt-12"> <!-- Hidden for anonymous users -->
            <h2 class="text-2xl font-semibold mb-4">My Personal Bells (Cloud Synced)</h2>

            <!-- Add Custom Bell Form -->
            <form id="add-personal-bell-form" class="bg-white p-6 rounded-xl shadow-md mb-8">
                <p id="personal-bell-status" class="text-sm text-gray-600 mb-4">Select a Personal Schedule from the dropdown above to add bells to it.</p>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="personal-bell-time" class="block text-sm font-medium text-gray-700 mb-1">Time (HH:MM:SS)</label>
                        <input type="time" id="personal-bell-time" step="1" required class="w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" disabled>
                    </div>
                    <!-- NEW: Custom Bell Name -->
                    <div>
                        <label for="personal-bell-name" class="block text-sm font-medium text-gray-700 mb-1">Bell Name</label>
                        <input type="text" id="personal-bell-name" placeholder="e.g. My Reminder" required class="w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" disabled>
                    </div>
                </div>
                <div class="flex flex-col sm:flex-row sm:items-end gap-4">
                    <div class="flex-grow" style="min-width: 120px;">
                        <label for="personal-bell-sound" class="block text-sm font-medium text-gray-700 mb-1">Sound</label>
                        <!-- MODIFIED: Sound select now uses optgroups -->
                        <select id="personal-bell-sound" class="w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" disabled>
                            <optgroup label="Default Sounds">
                                <option value="Bell">Bell</option>
                                <option value="Chime">Chime</option>
                                <option value="Beep">Beep</option>
                                <option value="Alarm">Alarm</option>
                                <!-- MODIFIED: Made Ellis Bell selected by default -->
                                <option value="ellisBell.mp3" selected>Ellis Bell</option>
                            </optgroup>
                            <optgroup label="My Sounds" id="personal-my-sounds-optgroup"></optgroup>
                            <optgroup label="Shared Sounds" id="personal-shared-sounds-optgroup"></optgroup>
                        </select>
                    </div>
                    <!-- MODIFIED: Changed button text from "Play" to icon -->
                    <button type="button" id="preview-personal-sound" class="w-10 h-10 flex-shrink-0 flex items-center justify-center text-lg bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors" aria-label="Preview" disabled>
                        &#9654;
                    </button>
                    <button type="submit" class="w-full sm:w-auto px-6 py-2 bg-green-600 text-white font-medium rounded-lg shadow-md hover:bg-green-700 transition-colors focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2" disabled>
                        Add Personal Bell
                    </button>
                </div>
            </form>
            
            <!-- NEW: v3.03 - Delete Personal Schedule Button -->
            <!-- MODIFIED: v3.05 - Moved into new Manager section -->
            <div class="bg-white p-6 rounded-xl shadow-md mb-8">
                <h3 class="text-xl font-semibold text-gray-800 border-b pb-2 mb-4">My Personal Schedule Manager</h3>
                
                <div class="space-y-3">
                    <button type="button" id="rename-personal-schedule-btn" class="w-full px-4 py-2 bg-blue-600 text-white font-medium rounded-lg shadow-md hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        Rename Selected Personal Schedule
                    </button>
                    
                    <button type="button" id="backup-personal-schedule-btn" class="w-full px-4 py-2 bg-green-600 text-white font-medium rounded-lg shadow-md hover:bg-green-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        Back up Selected Personal Schedule
                    </button>
                    
                    <button type="button" id="restore-personal-schedule-btn" class="w-full px-4 py-2 bg-yellow-500 text-black font-medium rounded-lg shadow-md hover:bg-yellow-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        Load/Overwrite Selected from Backup
                    </button>

                    <div class="border-t pt-3">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Delete Current Personal Schedule</label>
                        <button type="button" id="delete-personal-schedule-btn" class="w-full px-4 py-2 bg-red-600 text-white font-medium rounded-lg shadow-md hover:bg-red-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                            Delete Selected Personal Schedule
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- NEW: Audio Manager Panel (Hidden for anonymous users) -->
        <div id="audio-manager-panel" class="auth-required mt-12">
            <!-- MODIFIED: v3.09 - Made H2 a cursor-pointer -->
            <h2 class="text-2xl font-semibold mb-4 cursor-pointer" title="Click to refresh file lists">My Audio Manager</h2>
            <div class="bg-white p-6 rounded-xl shadow-md mb-8 space-y-6">
                
                <!-- Audio Upload Form -->
                <div>
                    <h3 class="text-lg font-medium text-gray-800 mb-2">Upload New Audio File</h3>
                    <p class="text-sm text-gray-600 mb-4">Files must be under 1MB. (Supports .mp3, .wav, .m4a, .ogg)</p>
                    <input type="file" id="audio-upload-input" accept=".mp3,.wav,.m4a,.ogg">
                    <div class="flex flex-col sm:flex-row gap-3">
                        <label for="audio-upload-input" class="w-full sm:w-auto cursor-pointer px-6 py-2 bg-blue-600 text-white font-medium rounded-lg shadow-md hover:bg-blue-700 transition-colors text-center">
                            Choose File...
                        </label>
                        <span id="audio-file-name" class="text-gray-700 sm:mt-2">No file chosen.</span>
                    </div>
                    <button type="button" id="audio-upload-btn" class="mt-3 w-full sm:w-auto px-6 py-2 bg-green-600 text-white font-medium rounded-lg shadow-md hover:bg-green-700 transition-colors disabled:opacity-50" disabled>
                        Upload Audio
                    </button>
                    <p id="audio-upload-status" class="text-blue-600 text-sm mt-3 hidden"></p>
                </div>

                <!-- My Audio Files List -->
                <div class="border-t pt-6">
                    <h3 class="text-lg font-medium text-gray-800 mb-2">My Audio Files</h3>
                    <div id="my-audio-files-list" class="space-y-2">
                        <p class="text-gray-500">Loading...</p>
                    </div>
                </div>

                <!-- Shared Audio Files List -->
                <div class="border-t pt-6">
                    <h3 class="text-lg font-medium text-gray-800 mb-2">Shared Audio Files</h3>
                    <div id="shared-audio-files-list" class="space-y-2">
                        <p class="text-gray-500">Loading...</p>
                    </div>
                </div>

            </div>
        </div>

        <!-- NEW: Footer for User ID and Credit -->
        <footer class="text-center p-4 mt-8 text-gray-500 text-sm border-t border-gray-200">
            <p class="mb-2">Web app enhanced by Google Gemini</p>
            <p>
                <code id="userIdDisplay" class="bg-gray-200 px-2 py-1 rounded">...</code>
            </p>
        </footer>
        
        <!-- NEW: v3.05 - Hidden file input for restore -->
        <input type="file" id="restore-file-input" class="hidden" accept="application/json,.json">

    </div>

        <!-- Firebase and App Logic -->
        <script type="module">
        // --- Firebase Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        
        import { getAuth, signInAnonymously, onAuthStateChanged, GoogleAuthProvider, signOut, signInWithPopup } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc, updateDoc, collection, getDocs, writeBatch, setLogLevel, deleteDoc, getDoc, addDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // MODIFIED: Removed refFromURL, which was causing the error.
        import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject, listAll, getMetadata, updateMetadata, getBytes } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

        // --- DOM Elements ---
        const welcomeOverlay = document.getElementById('welcome-overlay');
        const audioOverlay = document.getElementById('audio-overlay');
        const startAudioBtn = document.getElementById('start-audio-btn');
        
        const googleStartBtn = document.getElementById('google-start-btn');
        const anonymousStartBtn = document.getElementById('anonymous-start-btn');
        
        const countdownElement = document.getElementById('countdown-display');
        const clockElement = document.getElementById('live-clock-sentence');
        const statusElement = document.getElementById('status-message');
        const nextBellElement = document.getElementById('next-bell-sentence');
        const userIdElement = document.getElementById('userIdDisplay');
        // NEW: Added display name element
        const userDisplayNameElement = document.getElementById('user-display-name');
        const scheduleSelector = document.getElementById('schedule-selector');
        const scheduleTitle = document.getElementById('schedule-title');
        const adminToggleBtn = document.getElementById('admin-toggle');

        // MODIFIED: v3.21 -> v3.22 - Renamed from v3.21
        const nextBellInfoElement = document.getElementById('next-bell-info');

        // NEW: Quick Bell Elements
        const quickBellControls = document.getElementById('quickBellControls');
        const quickBellSoundSelect = document.getElementById('quickBellSoundSelect');

        // MODIFIED: Custom Bell Form -> Personal Bell Form (v3.03)
        const addPersonalBellForm = document.getElementById('add-personal-bell-form');
        const personalTimeInput = document.getElementById('personal-bell-time');
        const personalNameInput = document.getElementById('personal-bell-name'); 
        const personalSoundInput = document.getElementById('personal-bell-sound');
        const personalBellStatus = document.getElementById('personal-bell-status');
        const previewPersonalSoundBtn = document.getElementById('preview-personal-sound');
        const deletePersonalScheduleBtn = document.getElementById('delete-personal-schedule-btn');

        // Combined List
        const combinedBellListElement = document.getElementById('combined-bell-list');
        // DELETED: previewCustomSoundBtn (renamed)
        
        // Add Shared Bell Form (in Admin Zone)
        const addSharedBellForm = document.getElementById('add-shared-bell-form');
        const sharedTimeInput = document.getElementById('shared-bell-time');
        const sharedNameInput = document.getElementById('shared-bell-name');
        const sharedSoundInput = document.getElementById('shared-bell-sound');
        const previewSharedSoundBtn = document.getElementById('preview-shared-sound');
        const addSharedStatus = document.getElementById('add-shared-status');
        
        // Multi-Add Bell Modal
        const addBellModal = document.getElementById('add-bell-modal');
        const showAddBellModalBtn = document.getElementById('show-add-bell-modal-btn');
        const multiAddBellForm = document.getElementById('multi-add-bell-form');
        const multiBellTimeInput = document.getElementById('multi-bell-time');
        const multiBellNameInput = document.getElementById('multi-bell-name');
        const multiBellSoundInput = document.getElementById('multi-bell-sound');
        const multiScheduleListContainer = document.getElementById('multi-schedule-list-container');
        const multiAddCancelBtn = document.getElementById('multi-add-cancel');
        const multiAddSubmitBtn = document.getElementById('multi-add-submit');
        const multiAddStatus = document.getElementById('multi-add-status');
        const multiSelectAllBtn = document.getElementById('multi-select-all');
        const multiSelectNoneBtn = document.getElementById('multi-select-none');

        // Edit Bell Modal
        const editBellModal = document.getElementById('edit-bell-modal');
        const editBellForm = document.getElementById('edit-bell-form');
        const editBellTimeInput = document.getElementById('edit-bell-time');
        const editBellNameInput = document.getElementById('edit-bell-name');
        const editBellSoundInput = document.getElementById('edit-bell-sound');
        const editBellCancelBtn = document.getElementById('edit-bell-cancel');
        const editBellSubmitBtn = document.getElementById('edit-bell-submit');
        const editBellStatus = document.getElementById('edit-bell-status');

        // NEW: Change Sound Modal
        const changeSoundModal = document.getElementById('change-sound-modal');
        const changeSoundForm = document.getElementById('change-sound-form');
        const changeSoundBellName = document.getElementById('change-sound-bell-name');
        const changeSoundBellTime = document.getElementById('change-sound-bell-time');
        const changeSoundSelect = document.getElementById('change-sound-select');
        const changeSoundCancelBtn = document.getElementById('change-sound-cancel');
        // NEW: v3.19 - Play button for change sound modal
        const previewChangeSoundBtn = document.getElementById('preview-change-sound');

        // Linked Edit Modal
        const confirmLinkedEditModal = document.getElementById('confirm-linked-edit-modal');
        const linkedScheduleList = document.getElementById('linked-schedule-list');
        const linkedEditStatus = document.getElementById('linked-edit-status');
        const linkedEditCancel = document.getElementById('linked-edit-cancel');
        const linkedEditThisOnly = document.getElementById('linked-edit-this-only');
        const linkedEditApply = document.getElementById('linked-edit-apply');

        // Create/Delete Schedule
        const createScheduleForm = document.getElementById('create-schedule-form');
        const newScheduleNameInput = document.getElementById('new-schedule-name');
        const deleteScheduleBtn = document.getElementById('delete-schedule-btn');
        const confirmDeleteModal = document.getElementById('confirm-delete-modal');
        const confirmDeleteText = document.getElementById('confirm-delete-text');
        const deleteConfirmBtn = document.getElementById('delete-confirm');
        const deleteCancelBtn = document.getElementById('delete-cancel'); 

        // NEW: v3.03 - Create/Delete Personal Schedule
        const createPersonalScheduleBtn = document.getElementById('create-personal-schedule-btn');
        const createPersonalScheduleModal = document.getElementById('create-personal-schedule-modal');
        const createPersonalScheduleForm = document.getElementById('create-personal-schedule-form');
        const personalBaseScheduleName = document.getElementById('personal-base-schedule-name');
        const newPersonalScheduleNameInput = document.getElementById('new-personal-schedule-name');
        const createPersonalScheduleStatus = document.getElementById('create-personal-schedule-status');
        const createPersonalScheduleCancelBtn = document.getElementById('create-personal-schedule-cancel');
        const confirmDeletePersonalModal = document.getElementById('confirm-delete-personal-modal');
        const confirmDeletePersonalText = document.getElementById('confirm-delete-personal-text');
        const deletePersonalConfirmBtn = document.getElementById('delete-personal-confirm');
        const deletePersonalCancelBtn = document.getElementById('delete-personal-cancel');

        // NEW: v3.05 - Personal Schedule Manager Buttons
        const renamePersonalScheduleBtn = document.getElementById('rename-personal-schedule-btn');
        const backupPersonalScheduleBtn = document.getElementById('backup-personal-schedule-btn');
        const restorePersonalScheduleBtn = document.getElementById('restore-personal-schedule-btn');
        const restoreFileInput = document.getElementById('restore-file-input');
        
        // NEW: v3.05 - Restore Modal
        const confirmRestoreModal = document.getElementById('confirm-restore-modal');
        const confirmRestoreText = document.getElementById('confirm-restore-text');
        const restoreConfirmBtn = document.getElementById('restore-confirm');
        const restoreCancelBtn = document.getElementById('restore-cancel');

        // NEW: v3.26 - Rename Personal Schedule Modal
        const renamePersonalScheduleModal = document.getElementById('rename-personal-schedule-modal');
        const renamePersonalScheduleForm = document.getElementById('rename-personal-schedule-form');
        const renameOldScheduleName = document.getElementById('rename-old-schedule-name');
        const renameNewScheduleNameInput = document.getElementById('rename-new-schedule-name');
        const renamePersonalScheduleStatus = document.getElementById('rename-personal-schedule-status');
        const renamePersonalCancelBtn = document.getElementById('rename-personal-cancel');


        // Delete Bell Modal
        const confirmDeleteBellModal = document.getElementById('confirm-delete-bell-modal');
        const confirmDeleteBellText = document.getElementById('confirm-delete-bell-text');
        const deleteBellConfirmBtn = document.getElementById('delete-bell-confirm');
        const deleteBellCancelBtn = document.getElementById('delete-bell-cancel');

        // NEW: Delete Audio Modal
        const confirmDeleteAudioModal = document.getElementById('confirm-delete-audio-modal');
        const confirmDeleteAudioText = document.getElementById('confirm-delete-audio-text');
        const confirmDeleteAudioList = document.getElementById('confirm-delete-audio-list');
        const deleteAudioConfirmBtn = document.getElementById('delete-audio-confirm');
        const deleteAudioCancelBtn = document.getElementById('delete-audio-cancel');

        // **** NEW: Nearby Bell Warning Modal (Req 1 - Custom Bells ONLY) ****
        const nearbyBellModal = document.getElementById('nearby-bell-modal');
        const nearbyBellName = document.getElementById('nearby-bell-name');
        const nearbyBellTime = document.getElementById('nearby-bell-time');
        const nearbyBellStatus = document.getElementById('nearby-bell-status');
        const nearbyBellCustomControls = document.getElementById('nearby-bell-custom-controls');
        // DELETED: Old Admin Controls variable
        // const nearbyBellAdminControls = document.getElementById('nearby-bell-admin-controls');
        const nearbyBellCancelBtn = document.getElementById('nearby-bell-cancel');
        // MODIFIED: v3.25 - Renamed button ID for clarity
        const nearbyBellConfirmBtn = document.getElementById('nearby-bell-confirm');
        // DELETED: Old nearby-bell-admin-controls buttons
        // const nearbyBellMatchBtn = document.getElementById('nearby-bell-match');
        // const nearbyBellMatchTimeText = document.getElementById('nearby-bell-match-time-text');
        // const nearbyBellKeepBtn = document.getElementById('nearby-bell-keep');
        // const nearbyBellKeepTimeText = document.getElementById('nearby-bell-keep-time-text');
        // const nearbyBellAdminCancelBtn = document.getElementById('nearby-bell-admin-cancel');

        // NEW: Scenario 1 Modal Elements
        const internalConflictWarningModal = document.getElementById('internal-conflict-warning-modal');
        const internalConflictNewTime = document.getElementById('internal-conflict-new-time');
        const internalConflictExistingBell = document.getElementById('internal-conflict-existing-bell');
        const internalConflictCancelBtn = document.getElementById('internal-conflict-cancel');
        const internalConflictEditBtn = document.getElementById('internal-conflict-edit');
        const internalConflictConfirmBtn = document.getElementById('internal-conflict-confirm');
        
        const internalConflictConfirmModal = document.getElementById('internal-conflict-confirm-modal');
        const internalConflictFinalNewTime = document.getElementById('internal-conflict-final-new-time');
        const internalConflictFinalExisting = document.getElementById('internal-conflict-final-existing');
        const internalConflictFinalDiff = document.getElementById('internal-conflict-final-diff');
        const internalConflictFinalCancelBtn = document.getElementById('internal-conflict-final-cancel');
        const internalConflictFinalCreateBtn = document.getElementById('internal-conflict-final-create');

        // NEW: Scenario 2 Modal Elements
        const externalConflictModal = document.getElementById('external-conflict-modal');
        const externalConflictNewTime = document.getElementById('external-conflict-new-time');
        const externalConflictList = document.getElementById('external-conflict-list');
        const externalConflictStatus = document.getElementById('external-conflict-status');
        const externalConflictMatchBtn = document.getElementById('external-conflict-match-existing');
        const externalConflictMatchTime = document.getElementById('external-conflict-match-time');
        const externalConflictKeepBtn = document.getElementById('external-conflict-keep-new');
        const externalConflictKeepTime = document.getElementById('external-conflict-keep-time');
        const externalConflictCreateAndMatchBtn = document.getElementById('external-conflict-create-and-match');
        const externalConflictCancelBtn = document.getElementById('external-conflict-cancel');


        // Import/Export Elements
        const exportSchedulesBtn = document.getElementById('export-schedules-btn');
        const importSchedulesBtn = document.getElementById('import-schedules-btn');
        const importFileInput = document.getElementById('import-file-input');
        const importStatus = document.getElementById('import-status');

        // NEW: Audio Manager Elements
        const audioUploadInput = document.getElementById('audio-upload-input');
        const audioFileName = document.getElementById('audio-file-name');
        const audioUploadBtn = document.getElementById('audio-upload-btn');
        const audioUploadStatus = document.getElementById('audio-upload-status');
        const myAudioFilesList = document.getElementById('my-audio-files-list');
        const sharedAudioFilesList = document.getElementById('shared-audio-files-list');

        const signOutBtn = document.getElementById('signout-btn');

        // DELETED: v3.24 - Removed hardcoded admin list
        // const ADMIN_EMAIL_LIST = [ ... ];

        // --- App State ---
        let db, auth, storage; // NEW: Added storage
        let userId;
        let isUserAnonymous = true; // NEW: Track anonymous state
        let localSchedule = []; // Bells from the *base* shared schedule
        // DELETED: customBells = []; // This is GONE
        let personalBells = []; // NEW: Bells from the *active personal* schedule
        let scheduleRef; // For the *base* shared schedule
        let schedulesCollectionRef; // For *all* shared schedules
        let sharedSchedulesListenerUnsubscribe = null; // NEW: v3.24 - For shared schedules
        let allSchedules = []; // Array of *all* shared schedules
        let allPersonalSchedules = []; // NEW: Array of *user's* personal schedules
        let activeBaseScheduleId = null; // MODIFIED: Renamed from activeScheduleId
        let activePersonalScheduleId = null; // NEW: ID of active personal schedule
        let activeScheduleListenerUnsubscribe = null; // For base schedule
        let activePersonalScheduleListenerUnsubscribe = null; // NEW: For personal schedule
        let personalSchedulesListenerUnsubscribe = null; // NEW: v3.09 - For the collection
        let synths = {}; 
        let lastBellRingTime = null; 
        let lastRingTimestamp = 0; // NEW: For ring cooldown
        const RING_COOLDOWN = 5000; // 5 seconds (5000ms)
        let clockIntervalId = null; 
        
        let currentEditingBell = null; 
        let currentChangingSoundBell = null; // NEW: State for sound change
        let linkedEditData = null; 
        let bellToDelete = null; 
        let audioToDelete = null; // NEW: State for audio deletion

        // NEW: State for Req 1 (Now for Personal Bells)
        let pendingPersonalBell = null; 
        // NEW: v3.25 - State for personal bell edit vs. add
        let pendingPersonalBellAction = 'add';
        let pendingPersonalBellOriginal = null;
        
        // NEW: State for v3.02 logic
        let pendingSharedBell = null; // Stores { time, name, sound }
        let currentInternalConflict = null; // Stores the conflicting bell object
        let currentExternalConflicts = []; // Stores [{schedule, bell}]
        let pendingRestoreData = null; // v3.05: For schedule restore

        // NEW: Quick Bell State
        let quickBellEndTime = null;
        let quickBellSound = 'ellisBell.mp3'; // Default sound

        let mutedBellIds = new Set(); 
        let bellSoundOverrides = {}; // NEW: Store local sound overrides

        let appId; 
        let isAudioReady = false; 
        
        let keepAliveOscillator = null; // NEW in 3.47: "Anti-sleep" oscillator

        let oscillatorAlertInterval = null; // NEW in 3.48: For pre-bell wake-up
        let isOscillatorAlert = false; // NEW in 3.48: Flag for pre-bell wake-up

        let lastClockCheckTimestamp = 0; // NEW in 3.47: For missed bell recovery
        let currentDay = new Date().getDay(); // NEW in 3.47: To clear missed bells

        // NEW: Audio file state
        let userAudioFiles = []; // { name, url, path }
        let sharedAudioFiles = []; // { name, url, path }
        let fileToUpload = null; // Holds the File object
        const MAX_FILE_SIZE = 1024 * 1024; // 1MB

        // --- Mute Helper Functions ---
        function getBellId(bell) {
            if (!bell || !bell.type || !bell.time || !bell.name) return null;
            const safeName = bell.name.replace(/"/g, '&quot;');
            return `${bell.type}-${bell.time}-${safeName}`;
        }

        function loadMutedBells() {
            try {
                const stored = localStorage.getItem('mutedBellIds');
                if (stored) {
                    mutedBellIds = new Set(JSON.parse(stored));
                    console.log(`Loaded ${mutedBellIds.size} muted bell IDs.`);
                }
            } catch (e) {
                console.error("Failed to load muted bells", e);
                mutedBellIds = new Set();
            }
        }

        function saveMutedBells() {
            try {
                localStorage.setItem('mutedBellIds', JSON.stringify([...mutedBellIds]));
            } catch (e) {
                console.error("Failed to save muted bells", e);
            }
        }

        // --- NEW: Sound Override Functions ---
        function getBellOverrideKey(scheduleId, bell) {
            if (!scheduleId || !bell) return null;
            // MODIFIED: v3.03 - We only override 'shared' bells
            if (bell.type !== 'shared') return null;
            const bellId = getBellId(bell);
            if (!bellId) return null;
            return `${scheduleId}-${bellId}`;
        }

        function loadSoundOverrides() {
            try {
                const stored = localStorage.getItem('bellSoundOverrides');
                if (stored) {
                    bellSoundOverrides = JSON.parse(stored);
                    console.log(`Loaded ${Object.keys(bellSoundOverrides).length} sound overrides.`);
                }
            } catch (e) {
                console.error("Failed to load sound overrides", e);
                bellSoundOverrides = {};
            }
        }

        function saveSoundOverrides() {
            try {
                localStorage.setItem('bellSoundOverrides', JSON.stringify(bellSoundOverrides));
            } catch (e) {
                console.error("Failed to save sound overrides", e);
            }
        }

        // NEW: Helper to format 24h time to 12h AM/PM
        // MODIFIED: v3.22 - Added omitSecondsIfZero parameter
        function formatTime12Hour(timeString, omitSecondsIfZero = false) {
            if (!timeString) return "--:--";
            
            try {
                const parts = timeString.split(':');
                if (parts.length < 2) return timeString; // Not a valid time

                let [hours, minutes, seconds] = parts;
                hours = parseInt(hours, 10);

                const ampm = hours >= 12 ? 'PM' : 'AM';
                
                hours = hours % 12;
                hours = hours ? hours : 12; // '0' (midnight) should be '12'

                // 'hours' is now a number (1-12), so no leading zero.
                
                // NEW: v3.22 - Logic to omit seconds
                if (omitSecondsIfZero && seconds && parseInt(seconds, 10) === 0) {
                    seconds = null; // Don't display
                }

                if (seconds) {
                    return `${hours}:${minutes}:${seconds} ${ampm}`;
                } else {
                    return `${hours}:${minutes} ${ampm}`;
                }
            } catch (e) {
                console.error("Error formatting time:", e);
                return timeString; // Fallback to original
            }
        }


        // --- Audio Setup (Tone.js) ---
        async function startAudio() {
            if (isAudioReady) return;
            try {
                await Tone.start();
                console.log("AudioContext started.");
                setupSynths();
                isAudioReady = true;
                statusElement.textContent = "Audio ready. Monitoring bells...";

                if (auth.currentUser) {
                    console.log("Audio ready, user signed in. Starting clock.");
                    if (clockIntervalId) clearInterval(clockIntervalId);
                    updateClock(); 
                    clockIntervalId = setInterval(updateClock, 1000);
                }

                // NEW in 3.47: Start a silent, looping oscillator to prevent AudioContext suspension.
                if (!keepAliveOscillator) {
                    keepAliveOscillator = new Tone.Oscillator({
                        frequency: 1, // 1 Hz (inaudible)
                        volume: -100, // -100 dB (inaudible)
                    }).toDestination().start();
                    console.log("Started silent keep-alive oscillator.");
                }

            } catch (e) {
                console.error("Audio start failed:", e);
                statusElement.textContent = "Error starting audio. Please refresh.";
                throw e;
            }
        }

        function setupSynths() {
            // Setup default synths
            synths['Bell'] = new Tone.MetalSynth({
                frequency: 200,
                envelope: { attack: 0.001, decay: 0.4, release: 0.2 },
                harmonicity: 5.1,
                modulationIndex: 32,
                resonance: 4000,
                octaves: 1.5
            }).toDestination();

            synths['Chime'] = new Tone.Synth({
                oscillator: { type: 'sine' },
                envelope: { attack: 0.01, decay: 0.5, sustain: 0.1, release: 1 }
            }).toDestination();

            synths['Beep'] = new Tone.Synth({
                oscillator: { type: 'square' },
                envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.05 }
            }).toDestination();

            synths['Alarm'] = new Tone.MonoSynth({
                oscillator: { type: "sine" },
                envelope: { attack: 0.1, decay: 0.2, release: 0.1 }
            }).toDestination();
            
            // MODIFIED: v3.30 - Cache a load promise for ellisBell.mp3 for Safari
            synths['ellisBell.mp3'] = (async () => {
                try {
                    const player = new Tone.Player().toDestination();
                    await player.load("ellisBell.mp3");
                    console.log("ellisBell.mp3 pre-loaded.");
                    return player;
                } catch (e) {
                    console.error("ellisBell.mp3 failed to pre-load", e);
                    return null;
                }
            })();
        }

        async function playBell(soundName) {
            // --- MODIFIED: v3.43 ---
            // This is the complete, working logic from v2.24, adapted for v3.42.
            // It uses the `getBytes` and `decodeAudioData` method, which is more robust
            // than the URL-parsing logic that was failing.
            // It also correctly handles the pre-loaded promise for 'ellisBell.mp3'
            // and the built-in synths.
        
            if (!isAudioReady) {
                console.warn("Audio not ready. Cannot play bell.");
                try {
                    await startAudio();
                } catch (e) {
                    console.error("Audio start failed during playback attempt:", e);
                }
                return;
            }
        
            const now = Tone.now();
        
            // --- Case 1: Handle built-in synths ---
            if (soundName === 'Bell' || soundName === 'Chime' || soundName === 'Beep' || soundName === 'Alarm') {
                const synth = synths[soundName];
                try {
                    if (soundName === 'Bell') {
                        synth.triggerAttackRelease('C4', '0.5', now);
                        synth.triggerAttackRelease('G4', '0.5', now + 0.3);
                    } else if (soundName === 'Chime') {
                        synth.triggerAttackRelease('G5', '0.8', now);
                        synth.triggerAttackRelease('E6', '0.8', now + 0.5);
                    } else if (soundName === 'Beep') {
                        synth.triggerAttackRelease('A5', '0.1', now);
                    } else if (soundName === 'Alarm') {
                        synth.triggerAttackRelease("C5", "0.1", now);
                        synth.triggerAttackRelease("C5", "0.1", now + 0.15);
                        synth.triggerAttackRelease("C5", "0.1", now + 0.3);
                    }
                } catch (error) {
                    console.error("Error playing built-in synth:", error);
                }
                return; // Handled
            }
            
            // --- Case 2: Handle 'ellisBell.mp3' (pre-loaded promise) ---
            if (soundName === 'ellisBell.mp3') {
                try {
                    // This is a promise for a Player
                    const player = await synths['ellisBell.mp3']; 
                    if (player && player.loaded) {
                        player.start(now);
                    } else {
                        console.error("Ellis Bell player was not ready.");
                    }
                } catch (e) {
                    console.error(`Error playing ${soundName}:`, e);
                }
                return; // Handled
            }
        
            // --- Case 3: Handle all other sounds (Custom HTTP URLs or Paths) ---
            
            if (!soundName) {
                console.warn("playBell called with empty soundName. Reverting to default.");
                await playBell('ellisBell.mp3'); // Play default as a fallback
                return;
            }
        
            // Determine Cache Key
            // The soundName is the cacheKey, whether it's a full URL (legacy) or a path (new).
            // We create a new cache key prefix for Buffers to avoid conflicts with old cached Player promises.
            const bufferCacheKey = `buffer-${soundName}`;
        
            try {
                // Check cache for a pre-decoded AudioBuffer
                if (synths[bufferCacheKey] instanceof AudioBuffer) {
                    // console.log("Playing from AudioBuffer cache:", bufferCacheKey);
                    const player = new Tone.Player(synths[bufferCacheKey]).toDestination();
                    player.start(now);
                    return; // Played from cache
                }
        
                // Check if a promise for this buffer is already in flight
                if (synths[bufferCacheKey] && typeof synths[bufferCacheKey].then === 'function') {
                    // console.log("Waiting on in-flight buffer promise:", bufferCacheKey);
                    const buffer = await synths[bufferCacheKey];
                    if (buffer) {
                        const player = new Tone.Player(buffer).toDestination();
                        player.start(now);
                    } else {
                        // Promise resolved to null (it failed)
                        console.warn(`In-flight promise for ${bufferCacheKey} failed. Reverting to default.`);
                        await playBell('ellisBell.mp3');
                    }
                    return;
                }
        
                // --- Not in buffer cache. Fetch bytes. ---
                // console.log("Fetching bytes for buffer:", soundName);
                
                // Store the promise immediately to prevent race conditions
                const bufferPromise = (async () => {
                    try {
                        // This is the key insight from v2.24:
                        // `ref(storage, soundName)` works for *both* full URLs and paths.
                        const storageRef = ref(storage, soundName); 
                        const bytes = await getBytes(storageRef); // This is an ArrayBuffer
                        
                        // Decode the ArrayBuffer into an AudioBuffer
                        const audioBuffer = await Tone.context.decodeAudioData(bytes);
                        return audioBuffer; // Promise resolves to the buffer
                    
                    } catch (err) {
                        console.error(`Failed to getBytes or decode audio: ${soundName}`, err);
                        delete synths[bufferCacheKey]; // Clear bad promise
                        return null;
                    }
                })();
        
                synths[bufferCacheKey] = bufferPromise; // Cache the promise
        
                const newBuffer = await bufferPromise;
        
                if (newBuffer) {
                    synths[bufferCacheKey] = newBuffer; // Overwrite promise with resolved buffer
                    const player = new Tone.Player(newBuffer).toDestination();
                    player.start(now);
                } else {
                    // Fetching failed, play default as fallback
                    console.warn("Falling back to default bell.");
                    await playBell('ellisBell.mp3');
                }
                
            } catch (e) {
                console.error(`Error playing custom sound ${soundName}:`, e);
                delete synths[bufferCacheKey]; // Clear cache on error
                await playBell('ellisBell.mp3'); // Fallback
            }
        }

        // --- Clock and Bell Logic ---

        function findNextBell(currentTimeHHMMSS) {
            // MODIFIED: v3.03 - Merges base schedule and personal schedule bells
            const allBells = [...localSchedule, ...personalBells];
            if (allBells.length === 0) return null;
            
            let upcomingBells = allBells.filter(bell => bell.time > currentTimeHHMMSS);
            
            let nextBell;
            if (upcomingBells.length > 0) {
                upcomingBells.sort((a, b) => a.time.localeCompare(b.time));
                nextBell = upcomingBells[0];
            } else {
                allBells.sort((a, b) => a.time.localeCompare(b.time));
                nextBell = allBells[0];
            }
            return nextBell;
        }

        // --- NEW: v3.22 - Find the bell that rings after a given bell ---
        /**
         * Finds the bell scheduled immediately after the provided bell on the same day.
         * @param {object} currentBell - The bell object {time, name, ...}
         * @param {Array} allBells - The merged list of localSchedule and personalBells
         * @returns {object|null} The next bell object, or null if it's the last bell.
         */
        function findBellAfter(currentBell, allBells) {
            if (!currentBell || allBells.length === 0) return null;
            // Ensure list is sorted
            const sortedBells = [...allBells].sort((a, b) => a.time.localeCompare(b.time));
            
            const currentIndex = sortedBells.findIndex(b => b.time === currentBell.time && b.name === currentBell.name);
            
            if (currentIndex === -1) return null; // Bell not found
            
            if (currentIndex + 1 < sortedBells.length) {
                return sortedBells[currentIndex + 1]; // Return the next bell
            } else {
                return null; // This was the last bell of the day
            }
        }

        /**
         * NEW in 3.47: Helper to get a Date object for a bell's time on a specific day.
         * @param {string} timeString - The HH:MM:SS time of the bell.
         * @param {Date} referenceDate - The "current" date object (from updateClock).
         * @returns {Date} A Date object for the bell on the reference day.
         */
        function getDateForBellTime(timeString, referenceDate) {
            const [h, m, s] = timeString.split(':').map(Number);
            const bellDate = new Date(referenceDate);
            bellDate.setHours(h, m, s, 0); // Set time, clear milliseconds
            return bellDate;
        }

        // MODIFIED: v3.22 -> v3.23 - Grammar changes
        function updateClock() {
            const now = new Date();
            const nowTimestamp = now.getTime(); // Get current time in ms
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const currentTimeHHMMSS = `${hours}:${minutes}:${seconds}`;

            // --- 1. Update Live Clock Display ---
            // Use (false) to ensure seconds are always shown for the clock
            const formattedTime = formatTime12Hour(currentTimeHHMMSS, false); 
            // MODIFICATION: Removed period after "are"
            clockElement.textContent = `The time is ${formattedTime}. There are`;
            
            // --- 2. Find Bells & Calculate Timers ---
            const allBells = [...localSchedule, ...personalBells];
            const scheduleBellObject = findNextBell(currentTimeHHMMSS); // The bell we will count down to
            
            let millisToScheduleBell = Infinity;
            if (scheduleBellObject) {
                const [h, m, s] = scheduleBellObject.time.split(':').map(Number);
                const nextBellDate = new Date();
                nextBellDate.setHours(h, m, s, 0);
                millisToScheduleBell = nextBellDate.getTime() - nowTimestamp;
                if (millisToScheduleBell < 0) { // If bell time has passed for today
                    nextBellDate.setDate(nextBellDate.getDate() + 1);
                    millisToScheduleBell = nextBellDate.getTime() - nowTimestamp;
                }
            }

            const millisToQuickBell = quickBellEndTime ? quickBellEndTime.getTime() - nowTimestamp : Infinity;
            
            // --- 3. Determine Active Countdown & "Next Bell" Info ---
            let activeTimerLabel = null;
            let activeTimerMillis = Infinity;
            let isMuting = false;
            let nextBellInfoString = "No more bells today."; // Default "Next Bell" text

            if (millisToScheduleBell < millisToQuickBell && scheduleBellObject) {
                // --- A. Counting down to a SCHEDULE BELL ---
                activeTimerLabel = scheduleBellObject.name;
                activeTimerMillis = millisToScheduleBell;
                const nextBellId = getBellId(scheduleBellObject);
                isMuting = mutedBellIds.has(nextBellId);
                
                // Find the bell *after* this one for the info display
                const bellAfter = findBellAfter(scheduleBellObject, allBells);
                if (bellAfter) {
                    // Use (true) to omit seconds if they are 00
                    // MODIFICATION: Added period at the end
                    nextBellInfoString = `Next bell is ${bellAfter.name} at ${formatTime12Hour(bellAfter.time, true)}.`;
                } else {
                    nextBellInfoString = "No more bells today."; // Already has period
                }

            } else if (millisToQuickBell < millisToScheduleBell) {
                // --- B. Counting down to a QUICK BELL ---
                activeTimerLabel = "Quick Bell";
                activeTimerMillis = millisToQuickBell;
                isMuting = false;
                
                // The "next bell" info should be the next *schedule* bell
                if (scheduleBellObject) {
                    // Use (true) to omit seconds if they are 00
                    // MODIFICATION: Added period at the end
                    nextBellInfoString = `Next bell is ${scheduleBellObject.name} at ${formatTime12Hour(scheduleBellObject.time, true)}.`;
                } else {
                    nextBellInfoString = "No more bells today."; // Already has period
                }
            }
            
            // --- 4. Populate Countdown and "Next Bell" Elements ---
            nextBellInfoElement.textContent = nextBellInfoString;

            if (activeTimerLabel) {
                let totalSeconds = Math.max(0, Math.floor(activeTimerMillis / 1000));
                let cdHours = Math.floor(totalSeconds / 3600);
                totalSeconds %= 3600;
                let cdMinutes = Math.floor(totalSeconds / 60);
                let cdSeconds = totalSeconds % 60;
                let countdownString;
                
                if (cdHours > 0) {
                    countdownString = `${cdHours}:${String(cdMinutes).padStart(2, '0')}:${String(cdSeconds).padStart(2, '0')}`;
                } else if (cdMinutes > 0 || cdHours > 0) { // Show minutes if 1m or more
                    countdownString = `${cdMinutes}:${String(cdSeconds).padStart(2, '0')}`;
                } else {
                    countdownString = `${cdSeconds}`;
                }
                countdownElement.textContent = countdownString;
                
                if (isMuting) {
                    // MODIFICATION: Added period
                    nextBellElement.textContent = `until ${activeTimerLabel} (MUTED).`;
                } else {
                    // MODIFICATION: Added period
                    nextBellElement.textContent = `until ${activeTimerLabel}.`;
                }
            } else {
                // --- C. No active timer ---
                countdownElement.textContent = "--:--";
                // MODIFICATION: Added period
                nextBellElement.textContent = "until the next bell.";
                // "Next Bell" info is already set to "No more bells today."
                // Or, if school is out, scheduleBellObject is the first bell tomorrow.
                if (scheduleBellObject) {
                    // MODIFICATION: Added period
                    nextBellInfoString = `Next bell is ${scheduleBellObject.name} at ${formatTime12Hour(scheduleBellObject.time, true)}.`;
                    nextBellInfoElement.textContent = nextBellInfoString;
                } else {
                     nextBellInfoElement.textContent = "No bells scheduled."; // Already has period
                }
            }
    
            // --- NEW in 3.48: Pre-Bell Wake-up Logic ---
            // If a bell is approaching (under 60s) and we're not in "alert mode",
            // start "pulsing" the silent oscillator to keep the browser awake.
            // MODIFIED in 3.49: Widen window from 60s to 180s (3 minutes)
            if (activeTimerMillis < 180000 && !isOscillatorAlert && keepAliveOscillator) {
                // NEW in 3.49: Added timestamp to log
                const nowStr = formatTime12Hour(currentTimeHHMMSS, false);
                console.log(`Bell approaching. Entering oscillator alert mode. (Actual: ${nowStr})`);
                isOscillatorAlert = true;
                if (oscillatorAlertInterval) clearInterval(oscillatorAlertInterval); // Clear just in case
                
                // "Pulse" the volume of the silent oscillator every 2 seconds
                oscillatorAlertInterval = setInterval(() => {
                    if (keepAliveOscillator) {
                        // Ramp to slightly "louder" (still inaudible) and back
                        keepAliveOscillator.volume.rampTo(-99, 0.2);
                        setTimeout(() => {
                            if (keepAliveOscillator) {
                                keepAliveOscillator.volume.rampTo(-100, 0.2);
                            }
                        }, 1000); // 1s at -99, 1s at -100
                    }
                }, 2000);
            } 
            // If the next bell is far away and we're still in "alert mode", stop.
            // MODIFIED in 3.49: Widen window from 60s to 180s (3 minutes)
            else if (activeTimerMillis > 180000 && isOscillatorAlert && keepAliveOscillator) {
                // NEW in 3.49: Added timestamp to log
                const nowStr = formatTime12Hour(currentTimeHHMMSS, false);
                console.log(`Bell has passed. Exiting oscillator alert mode. (Actual: ${nowStr})`);
                isOscillatorAlert = false;
                if (oscillatorAlertInterval) {
                    clearInterval(oscillatorAlertInterval);
                    oscillatorAlertInterval = null;
                }
                // Ensure volume is reset
                keepAliveOscillator.volume.value = -100;
            }

            // --- 5. Ring Logic (MODIFIED in 3.47: Missed Bell Recovery) ---
            
            // A. Check if the day has rolled over. If so, clear the timestamp.
            const newDay = now.getDay();
            if (newDay !== currentDay) {
                console.log("Day has changed. Resetting missed bell check.");
                lastClockCheckTimestamp = 0; // Force reset
                currentDay = newDay;
            }

            // B. On first run, just set the timestamp and wait for the next second.
            if (lastClockCheckTimestamp === 0) {
                lastClockCheckTimestamp = nowTimestamp;
            } else if (nowTimestamp > lastClockCheckTimestamp) {
                // C. Find all bells that *should have* rung between the last check and now
                const bellsToRing = allBells.filter(bell => {
                    const bellDate = getDateForBellTime(bell.time, now);
                    const bellTimestamp = bellDate.getTime();
                    
                    return bellTimestamp > lastClockCheckTimestamp && // After the last check
                            bellTimestamp <= nowTimestamp;            // and at or before now
                });
                
                if (bellsToRing.length > 0) {
                    console.log(`Found ${bellsToRing.length} missed bell(s) to ring.`);
                    // Sort them just in case
                    bellsToRing.sort((a, b) => a.time.localeCompare(b.time));

                    // Ring them all, but only if cooldown has passed
                    if (nowTimestamp - lastRingTimestamp > RING_COOLDOWN) {
                        // For now, just ring the *last* one if multiple were missed
                        const bell = bellsToRing[bellsToRing.length - 1];
                        const bellId = getBellId(bell);
                        
                        if (mutedBellIds.has(bellId)) {
                            console.log(`Skipping bell (Muted): ${bell.name}`);
                            statusElement.textContent = `Skipped (Muted): ${bell.name}`;
                        } else {
                            ringBell(bell); // fire-and-forget
                        }
                        lastRingTimestamp = nowTimestamp; // Set cooldown
                    }
                }
            }
            
            // D. Always update the timestamp for the next check
            lastClockCheckTimestamp = nowTimestamp;

            // --- Ring Logic (Quick Bell) ---
            if (quickBellEndTime && nowTimestamp >= quickBellEndTime.getTime() && (nowTimestamp - lastRingTimestamp > RING_COOLDOWN)) {
                console.log("Ringing Quick Bell");
                ringBell({ name: "Quick Bell", sound: quickBellSound });
                // MODIFIED in 3.48: DO NOT set the lastRingTimestamp.
                // This prevents a quick bell from "eating" a nearby schedule bell.
                // lastRingTimestamp = nowTimestamp; 
                quickBellEndTime = null; // Clear the quick bell
            }

            // MODIFIED: Reset status text logic
            if (lastBellRingTime && lastBellRingTime !== currentTimeHHMMSS && (nowTimestamp - lastRingTimestamp > RING_COOLDOWN)) {
                lastBellRingTime = null;
                if (isAudioReady) statusElement.textContent = "Monitoring...";
            }
        }
        
        // --- NEW: Quick Bell Function ---
        function startQuickBell(minutes) {
            const now = new Date();
            quickBellEndTime = new Date(now.getTime() + minutes * 60000);
            console.log(`Quick bell set for ${minutes} minutes from now.`);
            updateClock(); // Update display immediately
        }
        
        async function ringBell(bell) {
            // NEW in 3.49: Detailed logging for ring accuracy
            const actualTime = new Date();
            const actualTimeHHMMSS = `${String(actualTime.getHours()).padStart(2, '0')}:${String(actualTime.getMinutes()).padStart(2, '0')}:${String(actualTime.getSeconds()).padStart(2, '0')}`;
            console.log(`Ringing bell: "${bell.name}" | Scheduled: ${bell.time} | Actual: ${actualTimeHHMMSS}`);
            
            await playBell(bell.sound); // Now awaits the async playBell
            statusElement.textContent = `Ringing: ${bell.name}`;
            const safeName = bell.name.replace(/"/g, '&quot;');
            const bellElement = document.querySelector(`[data-time="${bell.time}"][data-name="${safeName}"]`);
            if (bellElement) {
                bellElement.classList.add('bg-blue-100');
                setTimeout(() => {
                    bellElement.classList.remove('bg-blue-100');
                }, 3000); 
            }
        }

        // --- Render Functions ---
        function renderCombinedList() {
            // MODIFIED: v3.03 - Merges base schedule and personal schedule bells
            const allBells = [...localSchedule, ...personalBells];
            allBells.sort((a, b) => a.time.localeCompare(b.time));

            if (allBells.length === 0) {
                combinedBellListElement.innerHTML = `<div class="p-8 text-center text-gray-500">No bells scheduled for this day.</div>`;
                return;
            }

            combinedBellListElement.innerHTML = allBells.map((bell, index) => {
                const isCustom = bell.type === 'custom';
                const isFirst = index === 0;
                const safeName = bell.name.replace(/"/g, '&quot;');
                const bellId = getBellId(bell);
                const isMuted = mutedBellIds.has(bellId);
                const originalSound = bell.originalSound || bell.sound; // NEW: Get original sound
                const isOverridden = bell.sound !== originalSound; // NEW: Check if overridden

                // Truncate long sound URLs for display
                let soundDisplay = bell.sound;
                if (soundDisplay && soundDisplay.startsWith('http')) {
                    try {
                        const url = new URL(soundDisplay);
                        // MODIFICATION: Decode path, THEN split by '/' and get filename
                        let path = decodeURIComponent(url.pathname.split('/').pop());
                        soundDisplay = path.split('/').pop(); // Get just the filename
                    } catch (e) {
                        soundDisplay = "Custom Sound";
                    }
                } else if (soundDisplay === 'ellisBell.mp3') {
                    soundDisplay = "Ellis Bell";
                } else if (!soundDisplay) {
                    soundDisplay = "No Sound";
                }
                
                // NEW: Add prefix if overridden
                if (isOverridden) {
                    soundDisplay = `Custom: ${soundDisplay}`;
                }


                // MODIFIED: v3.19 - Reordered controls
                return `
                    <div class="bell-item flex items-center justify-between p-4 ${!isFirst ? 'border-t border-gray-200' : ''} hover:bg-gray-50 transition-colors"
                         data-time="${bell.time}" data-name="${safeName}" 
                         data-sound="${bell.sound}" data-type="${bell.type}"
                         data-original-sound="${originalSound}"> <!-- NEW: Store original sound -->
                        
                        <!-- Bell Info (Time, Name, Sound) (left) -->
                        <div class="flex items-center space-x-4 min-w-0 flex-grow">
                            <!-- MODIFIED: v3.22 - Use (false) to always show seconds in list -->
                            <span class="text-xl font-medium text-blue-600 tabular-nums">${formatTime12Hour(bell.time, false)}</span>
                            <div class="min-w-0">
                                <span class="font-medium text-gray-800 truncate block" title="${safeName}">${safeName}</span>
                                <!-- MODIFIED: Updated sound display logic -->
                                <span class="text-sm ${isOverridden ? 'text-blue-600' : 'text-gray-500'} truncate block" title="${bell.sound}">(${soundDisplay})</span>
                                ${isCustom ? '<span class="ml-2 text-xs font-semibold bg-purple-200 text-purple-800 px-2 py-0.5 rounded-full">PERSONAL</span>' : ''}
                            </div>
                        </div>
                        
                        <!-- Right side controls (Audio + Admin) -->
                        <div class="flex-shrink-0 flex flex-col sm:flex-row sm:items-center sm:space-x-4 gap-2 sm:gap-0">
                        
                            <!-- Group 1: Audio Controls (Sound, Play, Mute) -->
                            <div class="flex items-center space-x-2">
                                
                                <!-- 1. "Sound" Button (Shared Bells only) -->
                                <button class="sound-btn px-3 py-1 text-sm bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
                                        style="${isCustom ? 'display: none;' : ''}"
                                        aria-label="Change sound for ${safeName}"
                                        title="Change sound">Sound</button>
                                
                                <!-- 2. "Play" Button (NEW for all bells) -->
                                <!-- **** MODIFIED: v3.20 - Changed classes for alignment **** -->
                                <button class="preview-bell-btn px-3 py-1 text-sm bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300" 
                                        aria-label="Play sound for ${safeName}"
                                        title="Play Sound">&#9654;</button>

                                <!-- 3. "Mute" Control (Label + Checkbox) -->
                                <label class="flex items-center space-x-2 cursor-pointer p-1"> <!-- Added p-1 for better touch target -->
                                    <span class="text-sm font-medium text-gray-700">Mute</span>
                                    <input type="checkbox" class="bell-mute-toggle h-5 w-5 text-blue-600 rounded focus:ring-blue-500" 
                                           data-bell-id="${bellId}" ${isMuted ? 'checked' : ''} 
                                           aria-label="Mute this bell">
                                </label>
                            </div>

                            <!-- Group 2: Admin/Edit Controls -->
                            <div class="flex-shrink-0 space-x-2">
                                <!-- Admin-only Edit (Time/Name) button -->
                                <button class="edit-btn px-3 py-1 text-sm bg-yellow-500 text-white rounded-lg hover:bg-yellow-600"
                                        aria-label="Edit shared bell ${safeName}"
                                        title="Edit shared bell">Edit</button>
                                
                                <!-- Admin-only Delete button -->
                                <button class="delete-btn px-3 py-1 text-sm bg-red-500 text-white rounded-lg hover:bg-red-600"
                                        aria-label="Delete shared bell ${safeName}"
                                        title="Delete shared bell">Delete</button>
                                
                                <!-- Custom Bell Edit (Time/Name/Sound) button -->
                                <button class="edit-custom-btn px-3 py-1 text-sm bg-yellow-500 text-white rounded-lg hover:bg-yellow-600"
                                        style="${!isCustom ? 'display: none;' : ''}"
                                        aria-label="Edit custom bell ${safeName}"
                                        title="Edit custom bell">Edit</button>
                                
                                <!-- Custom Bell Delete button -->
                                <button class="delete-custom-btn px-3 py-1 text-sm bg-red-500 text-white rounded-lg hover:bg-red-600"
                                        style="${!isCustom ? 'display: none;' : ''}"
                                        aria-label="Delete custom bell ${safeName}"
                                        title="Delete custom bell">Delete</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderScheduleSelector() {
            // MODIFIED: v3.03 - Renders with optgroups
            const lastSelectedId = localStorage.getItem('activeScheduleId') || (allSchedules.length > 0 ? `shared-${allSchedules[0].id}` : '');
            
            if (allSchedules.length === 0 && allPersonalSchedules.length === 0) {
                 scheduleSelector.innerHTML = '<option value="">No schedules found. Create one!</option>';
                 setActiveSchedule(""); 
                 return;
            }
            
            let personalOptions = allPersonalSchedules.map(schedule => 
                `<option value="personal-${schedule.id}" ${`personal-${schedule.id}` === lastSelectedId ? 'selected' : ''}>
                    ${schedule.name} (Personal)
                </option>`
            ).join('');

            let sharedOptions = allSchedules.map(schedule => 
                `<option value="shared-${schedule.id}" ${`shared-${schedule.id}` === lastSelectedId ? 'selected' : ''}>
                    ${schedule.name}
                </option>`
            ).join('');

            scheduleSelector.innerHTML = `
                <optgroup label="My Personal Schedules" id="personal-schedules-optgroup">
                    ${personalOptions || '<option value="" disabled>No personal schedules created.</option>'}
                </optgroup>
                <optgroup label="Shared Schedules" id="shared-schedules-optgroup">
                    ${sharedOptions}
                </optgroup>
            `;
            
            // If the lastSelectedId isn't in the list, default to the first shared schedule
            if (scheduleSelector.value) {
                // MODIFIED: v3.09 - Only call setActiveSchedule if the value is *different*
                // to prevent loops with the new listener
                const currentActive = activePersonalScheduleId ? `personal-${activePersonalScheduleId}` : `shared-${activeBaseScheduleId}`;
                if (scheduleSelector.value !== currentActive) {
                    setActiveSchedule(scheduleSelector.value);
                }
            } else if (allSchedules.length > 0) {
                setActiveSchedule(`shared-${allSchedules[0].id}`);
            } else {
                setActiveSchedule(``); // No schedules at all
            }
        }

        // --- Local Storage (Custom Bells) ---
        // DELETED: v3.03 - loadCustomBells() and saveCustomBells() removed
        
        // --- NEW: Helper Functions for Req 1, 2, 3 ---
        
        /**
         * Helper to convert "HH:MM:SS" to total seconds.
         * @param {string} time - The time string (HH:MM:SS)
         * @returns {number} Total seconds from midnight
         */
        function timeToSeconds(time) {
            try {
                const [h, m, s] = time.split(':').map(Number);
                return (h * 3600) + (m * 60) + (s || 0); // Handle "HH:MM" or "HH:MM:SS"
            } catch (e) {
                return NaN;
            }
        }

        /**
         * Finds a bell within 60 seconds of the given time.
         * @param {string} time - The time to check (HH:MM:SS)
         * @param {Array} bellList - The list of bells to check against
         * @param {object} [excludeBell=null] - A bell object {time, name} to exclude from the check
         * @returns {object|null} The nearby bell object or null
         */
        function findNearbyBell(time, bellList, excludeBell = null) {
            const newTimeInSeconds = timeToSeconds(time);
            if (isNaN(newTimeInSeconds)) return null;

            for (const bell of bellList) {
                // Exclude the bell we're currently editing
                if (excludeBell && bell.time === excludeBell.time && bell.name === excludeBell.name) {
                    continue;
                }
                
                const existingTimeInSeconds = timeToSeconds(bell.time);
                if (isNaN(existingTimeInSeconds)) continue;

                if (Math.abs(newTimeInSeconds - existingTimeInSeconds) <= 60) {
                    return bell; // Found a bell within 60 seconds
                }
            }
            return null;
        }
        
        // NEW: Helper to close and reset the nearby bell modal (Custom bells)
        // MODIFIED: v3.25 - Reset new state variables
        function closeNearbyBellModal() {
            nearbyBellModal.classList.add('hidden');
            nearbyBellStatus.classList.add('hidden');
            pendingPersonalBell = null; // MODIFIED: v3.03
            pendingPersonalBellAction = 'add';
            pendingPersonalBellOriginal = null;
            // DELETED: pendingSharedBell is no longer used by this modal
        }

        // NEW: Function to add the pending custom bell (Req 1)
        // MODIFIED: v3.03 - Now adds to Firestore
        // MODIFIED: v3.25 - Renamed from addPendingPersonalBell, now part of confirmPending...
        async function executeAddPersonalBell() {
            if (!pendingPersonalBell || !activePersonalScheduleId) return;
            const { time, name, sound, type } = pendingPersonalBell;
            
            const personalScheduleRef = doc(db, 'artifacts', appId, 'users', userId, 'personal_schedules', activePersonalScheduleId);

            try {
                const docSnap = await getDoc(personalScheduleRef);
                if (!docSnap.exists()) {
                    console.error("Personal schedule doc not found.");
                    return;
                }
                const existingBells = docSnap.data().bells || [];

                if (existingBells.find(b => b.time === time && b.name === name)) {
                    console.warn("This personal bell already exists.");
                } else {
                    const newBell = { time, name, sound }; // Don't save 'type'
                    const updatedBells = [...existingBells, newBell];
                    await updateDoc(personalScheduleRef, { bells: updatedBells });
                }
                
                addPersonalBellForm.reset();
                personalSoundInput.value = 'ellisBell.mp3';
            } catch (error) {
                console.error("Error adding pending personal bell:", error);
            } finally {
                closeNearbyBellModal();
            }
        }
        
        // DELETED: Old addPendingSharedBell function. This is now replaced
        // by the v3.02 logic in handleAddSharedBell and the new modal handlers.

        // --- End of NEW Helper Functions ---
        
        // MODIFIED: v3.03 - handleAddCustomBell -> handleAddPersonalBell
        // MODIFIED: v3.25 - Use nearby bell modal state
        async function handleAddPersonalBell(e) {
            e.preventDefault();
            if (!activePersonalScheduleId) {
                console.warn("No active personal schedule.");
                return;
            }

            const time = personalTimeInput.value;
            const name = personalNameInput.value;
            const sound = personalSoundInput.value;
            
            if (!time || !name) {
                console.warn("Please provide a time and name for the personal bell.");
                return;
            }
            
            // REQ 1 CHECK
            const allBells = [...localSchedule, ...personalBells];
            const nearbyBell = findNearbyBell(time, allBells);
            
            if (nearbyBell) {
                // Store pending bell
                pendingPersonalBell = { time, name, sound, type: 'custom' };
                // v3.25: Set action type
                pendingPersonalBellAction = 'add';
                pendingPersonalBellOriginal = null;
                
                // Show modal
                nearbyBellName.textContent = nearbyBell.name;
                nearbyBellTime.textContent = formatTime12Hour(nearbyBell.time, true); // v3.22
                nearbyBellCustomControls.style.display = 'flex';
                nearbyBellModal.classList.remove('hidden');
            } else {
                // No conflict, add directly
                const personalScheduleRef = doc(db, 'artifacts', appId, 'users', userId, 'personal_schedules', activePersonalScheduleId);
                try {
                    const docSnap = await getDoc(personalScheduleRef);
                    if (!docSnap.exists()) {
                        console.error("Personal schedule doc not found.");
                        return;
                    }
                    const existingBells = docSnap.data().bells || [];
                    
                    if (existingBells.find(b => b.time === time && b.name === name)) {
                        console.warn("This personal bell already exists.");
                        return;
                    }
                    
                    const newBell = { time, name, sound }; // Don't save 'type'
                    const updatedBells = [...existingBells, newBell];
                    await updateDoc(personalScheduleRef, { bells: updatedBells });

                    addPersonalBellForm.reset();
                    personalSoundInput.value = 'ellisBell.mp3';
                } catch (error) {
                    console.error("Error adding personal bell:", error);
                }
            }
        }

        // --- Firebase Logic ---
        // 3.44?  That's going to be it, I tell you.
        async function initFirebase() {
            if (auth) return; 
        
            try {
                // MODIFIED: v3.36 - Restored hardcoded config from v3.34.
                // The dynamic config check was for the canvas environment and
                // failed on GitHub Pages. This is the correct config.
                const firebaseConfig = {
                    apiKey: "AIzaSyDfo45UBu-pR8nqMQhVlS_QgyYZ2kzBdvM",
                    authDomain: "ellisbell-c185c.firebaseapp.com", 
                    projectId: "ellisbell-c185c",
                    storageBucket: "ellisbell-c185c.firebasestorage.app",
                    appId: "1:441560045695:web:94e51a006663404b8f474a"
                };
                
                // MODIFIED: v3.36 - Set global appId from hardcoded config
                appId = firebaseConfig.appId;
                
                const app = initializeApp(firebaseConfig);
                
                db = getFirestore(app);
                auth = getAuth(app);
                storage = getStorage(app); // NEW: Initialize Storage
                
                setLogLevel('Debug');
        
                // MODIFIED: v3.44 - REMOVED the automatic signInAnonymously() block.
                // The onAuthStateChanged listener will now correctly
                // see a null user on initial load, prompting the welcome overlay.
                
                /*
                DELETED in v3.44:
                try {
                    // Check if token exists and is not an empty string
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) { 
                        await signInWithCustomToken(auth, __initial_auth_token);
                        console.log("Signed in with custom token.");
                    } else { 
                        // Fallback to anonymous sign-in if no token is provided
                        await signInAnonymously(auth);
                        console.log("Signed in anonymously.");
                    }
                } catch (authError) {
                    console.error("Error during initial sign-in:", authError);
                    statusElement.textContent = "Error: Could not sign in.";
                    // Don't stop here, let onAuthStateChanged handle the null user state
                }
                */
                
                 onAuthStateChanged(auth, async (user) => {
                    // Clear admin state on any auth change
                    document.body.classList.remove('admin-mode');
                    adminToggleBtn.textContent = 'Toggle Admin';
        
                    if (user) {
                        console.log("User is signed in:", user.uid);
                        userId = user.uid;
                        isUserAnonymous = user.isAnonymous; // NEW: Track anonymous state
                        welcomeOverlay.classList.add('hidden'); 
                        
                        // NEW: Handle visibility based on anonymous state
                        if (user.isAnonymous) {
                            document.body.classList.remove('not-anonymous');
                        } else {
                            document.body.classList.add('not-anonymous');
                        }
                        
                        if (!isAudioReady) {
                            console.log("User is signed in, but audio not ready. Showing audio start button.");
                            
                            // NEW: Set custom button text based on user
                            let btnText = "Click to Start Audio";
                            if (user.isAnonymous) {
                                btnText = "You're logged in anonymously, so let's get started!";
                            } else {
                                const name = user.displayName || user.email;
                                btnText = `You're already logged in as ${name}, so let's get started!`;
                            }
                            startAudioBtn.textContent = btnText;
                            
                            audioOverlay.classList.remove('hidden');
                        } else {
                            console.log("User signed in, audio ready. Starting clock.");
                            if (clockIntervalId) clearInterval(clockIntervalId);
                            updateClock();
                            clockIntervalId = setInterval(updateClock, 1000);
                        }
        
                        document.body.classList.add('authenticated');
                        signOutBtn.classList.remove('hidden');
                        if (user.isAnonymous) {
                           userIdElement.textContent = `Anonymous ID: ${user.uid}`;
                           // NEW: Set header display name
                           userDisplayNameElement.textContent = "Signed in as: Anonymous";
                        } else {
                           // MODIFIED: Display User ID in the footer, not the header
                           userIdElement.textContent = `User ID: ${user.uid}`;
                           // NEW: Set header display name
                           const displayName = user.displayName || user.email;
                           userDisplayNameElement.textContent = `Signed in as: ${displayName}`;
                        }
        
                        // MODIFIED: v3.24 - Admin Check now ONLY checks Firestore
                        let isAdmin = false; // Local admin flag
                        if (!user.isAnonymous && user.uid) { // Check for non-anonymous user
                            try {
                                const adminDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'admins', user.uid);
                                const adminDocSnap = await getDoc(adminDocRef);
                                
                                if (adminDocSnap.exists()) {
                                    console.log("Server admin status confirmed for user:", user.email);
                                    isAdmin = true;
                                } else {
                                    console.log("Standard user detected:", user.email);
                                }
                            } catch (err) {
                                console.error("Error checking admin status:", err);
                            }
                        } else {
                             console.log("Anonymous user, skipping admin check.");
                        }
        
                        // NEW: Enable admin toggle *only* if server-side check passed
                        if (isAdmin) {
                            adminToggleBtn.disabled = false;
                            adminToggleBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                            adminToggleBtn.title = "Toggle administrator controls";
                        } else {
                            adminToggleBtn.disabled = true;
                            adminToggleBtn.classList.add('opacity-50', 'cursor-not-allowed');
                            adminToggleBtn.title = "Admin access required";
                        }
                        
                        // NEW: v3.03 - Also load personal schedules
                        if (!user.isAnonymous) {
                            // MODIFIED: v3.09 - Start real-time listener instead of one-time load
                            listenForPersonalSchedules(user.uid);
                        } else {
                            allPersonalSchedules = []; // Clear personal schedules
                        }
                        schedulesCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'schedules');
                        // MODIFIED: v3.24 - Changed to real-time listener
                        await listenForSharedSchedules(); 
                        
                        // NEW: Load audio files if not anonymous
                        if (!user.isAnonymous) {
                            await loadAllAudioFiles();
                        } else {
                            // If user is anonymous, clear/hide audio file lists
                            userAudioFiles = [];
                            sharedAudioFiles = []; // They can still see shared, but let's load them
                            await loadAllAudioFiles(); // Load only shared files
                            renderAudioFileManager();
                            updateSoundDropdowns();
                        }
                        
                        if (isAudioReady) {
                            statusElement.textContent = "Connected. Monitoring bells...";
                        } else {
                            statusElement.textContent = "Connected. Waiting for audio.";
                        }
        
        
                     } else {
                        console.log("User is signed out.");
                        userId = null;
                        isUserAnonymous = true;
                        
                        // NEW in 3.47: Stop the keep-alive oscillator
                        if (keepAliveOscillator) {
                            keepAliveOscillator.stop();
                            keepAliveOscillator.dispose();
                            keepAliveOscillator = null;
                        }
                        
                        // NEW in 3.48: Stop the alert interval
                        if (oscillatorAlertInterval) {
                            clearInterval(oscillatorAlertInterval);
                            oscillatorAlertInterval = null;
                        }
                        isOscillatorAlert = false; // Reset flag

                        if (clockIntervalId) {
                            clearInterval(clockIntervalId);
                            clockIntervalId = null;
                        }
        
                        // NEW: v3.09 - Unsubscribe from personal schedules
                        if (personalSchedulesListenerUnsubscribe) {
                            personalSchedulesListenerUnsubscribe();
                            personalSchedulesListenerUnsubscribe = null;
                        }
                        // NEW: v3.24 - Unsubscribe from shared schedules
                        if (sharedSchedulesListenerUnsubscribe) {
                            sharedSchedulesListenerUnsubscribe();
                            sharedSchedulesListenerUnsubscribe = null;
                        }
                        
                        document.body.classList.remove('authenticated', 'not-anonymous', 'admin-mode');
                        signOutBtn.classList.add('hidden');
                        userIdElement.textContent = "Not signed in.";
                        userDisplayNameElement.textContent = ""; // NEW: Clear header display name
                        adminToggleBtn.disabled = true;
                        adminToggleBtn.classList.add('opacity-50', 'cursor-not-allowed');
                        adminToggleBtn.title = "Sign in to see admin options";
                        
                        localSchedule = [];
                        personalBells = []; // NEW: v3.03
                        allSchedules = [];
                        allPersonalSchedules = []; // NEW: v3.03
                        renderScheduleSelector();
                        renderCombinedList();
                        statusElement.textContent = "Please sign in to load schedules.";
                        
                        clockElement.textContent = `Please sign in`;
                        countdownElement.textContent = "--:--";
                        nextBellElement.textContent = `to load the schedule.`;
                       
                        welcomeOverlay.classList.remove('hidden');
                        audioOverlay.classList.add('hidden');
                     }
                 });
        
            } catch (error) {
                console.error("Firebase Init Error:", error);
                statusElement.textContent = "Error connecting to Firebase.";
            }
        }
        
        // DELETED: v3.09 - loadPersonalSchedules() was removed and replaced by listenForPersonalSchedules()

        // NEW: v3.09 - Replaces loadPersonalSchedules with a real-time listener
        function listenForPersonalSchedules(userId) {
            if (isUserAnonymous || !userId) {
                allPersonalSchedules = [];
                renderScheduleSelector(); // Make sure to re-render
                return;
            }

            // Clean up old listener if it exists
            if (personalSchedulesListenerUnsubscribe) {
                personalSchedulesListenerUnsubscribe();
            }

            const personalSchedulesRef = collection(db, 'artifacts', appId, 'users', userId, 'personal_schedules');
            
            console.log("Listening for real-time personal schedule updates...");
            
            personalSchedulesListenerUnsubscribe = onSnapshot(personalSchedulesRef, (querySnapshot) => {
                allPersonalSchedules = querySnapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data() // name, baseScheduleId, bells[]
                }));
                allPersonalSchedules.sort((a, b) => a.name.localeCompare(b.name));
                
                console.log("Personal schedules updated from snapshot:", allPersonalSchedules.length);
                
                // CRITICAL: We must re-render the selector AND check if the active schedule still exists
                const currentSelectedValue = scheduleSelector.value;
                const activeScheduleExists = allPersonalSchedules.some(s => `personal-${s.id}` === currentSelectedValue);

                renderScheduleSelector(); // This re-renders the list
                
                // If the currently selected schedule was a personal one and it still exists, keep it.
                // If it was deleted, renderScheduleSelector's logic will pick a default.
                if (currentSelectedValue.startsWith('personal-') && activeScheduleExists) {
                    scheduleSelector.value = currentSelectedValue;
                    // Note: We don't call setActiveSchedule here, as renderScheduleSelector's
                    // default logic will handle picking the right schedule, and
                    // we don't want to trigger a listener loop.
                } else if (!currentSelectedValue.startsWith('personal-')) {
                    // Do nothing, the shared schedule selection is fine
                } else {
                    // The active personal schedule was deleted, setActiveSchedule will be
                    // called by renderScheduleSelector's default logic.
                    console.log("Active personal schedule was deleted. Reverting to default.");
                }

            }, (error) => {
                console.error("Error listening to personal schedules: ", error);
            });
        }


        // MODIFIED: v3.24 - Renamed from loadSharedSchedules, converted to onSnapshot
        async function listenForSharedSchedules() {
            if (sharedSchedulesListenerUnsubscribe) {
                sharedSchedulesListenerUnsubscribe(); // Unsubscribe from old one if exists
            }
            if (!schedulesCollectionRef) {
                 schedulesCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'schedules');
            }

            console.log("Listening for real-time shared schedule updates...");

            sharedSchedulesListenerUnsubscribe = onSnapshot(schedulesCollectionRef, (querySnapshot) => {
                allSchedules = querySnapshot.docs.map(doc => ({
                    id: doc.id,
                    name: doc.data().name || "Unnamed Schedule",
                    bells: doc.data().bells || []
                }));
                allSchedules.sort((a, b) => a.name.localeCompare(b.name));
                console.log("Shared schedules updated from snapshot:", allSchedules.length);

                // The dropdown is disabled by default, we must enable it now.
                scheduleSelector.disabled = false;
                
                // CRITICAL: We must re-render the selector AND check if the active schedule still exists
                const currentSelectedValue = scheduleSelector.value;
                const activeScheduleExists = allSchedules.some(s => `shared-${s.id}` === currentSelectedValue);

                renderScheduleSelector(); // This re-renders the list
                
                // If the currently selected schedule was a shared one and it still exists, keep it.
                if (currentSelectedValue.startsWith('shared-') && activeScheduleExists) {
                    scheduleSelector.value = currentSelectedValue;
                } else if (currentSelectedValue.startsWith('personal-')) {
                    // Do nothing, the personal schedule selection is fine
                } else {
                    // The active shared schedule was deleted, or no schedule was selected
                    // renderScheduleSelector's default logic will handle this.
                    console.log("Active shared schedule was deleted or none selected. Reverting to default.");
                }

            }, (error) => {
                console.error("Error listening to shared schedules: ", error);
                statusElement.textContent = "Error loading schedules.";
            });
        }

        // MODIFIED: v3.03 - Complete rewrite to handle personal and shared schedules
        function setActiveSchedule(prefixedId) {
            // Unsubscribe from *both* listeners
            if (activeScheduleListenerUnsubscribe) {
                activeScheduleListenerUnsubscribe();
                activeScheduleListenerUnsubscribe = null;
            }
            if (activePersonalScheduleListenerUnsubscribe) {
                activePersonalScheduleListenerUnsubscribe();
                activePersonalScheduleListenerUnsubscribe = null;
            }

            // Reset bell arrays
            localSchedule = [];
            personalBells = [];
            
            // v3.05: Disable manager buttons
            renamePersonalScheduleBtn.disabled = true;
            backupPersonalScheduleBtn.disabled = true;
            restorePersonalScheduleBtn.disabled = true;

            // v3.03: Disable personal schedule buttons
            createPersonalScheduleBtn.disabled = true;
            createPersonalScheduleBtn.textContent = 'Copy as Personal Schedule';
            deletePersonalScheduleBtn.disabled = true;
            deletePersonalScheduleBtn.classList.add('opacity-50', 'cursor-not-allowed');
            
            if (document.body.classList.contains('admin-mode')) {
                addSharedBellForm.querySelector('button[type="submit"]').disabled = true;
            }

            if (!prefixedId) {
                console.warn("No schedule ID provided.");
                activeBaseScheduleId = null;
                activePersonalScheduleId = null;
                scheduleTitle.textContent = "No Schedule Selected";
                renderCombinedList();
                return;
            }

            localStorage.setItem('activeScheduleId', prefixedId);
            const [type, scheduleId] = prefixedId.split('-');

            if (type === 'shared') {
                console.log("Setting active SHARED schedule:", scheduleId);
                activeBaseScheduleId = scheduleId;
                activePersonalScheduleId = null;

                const scheduleData = allSchedules.find(s => s.id === scheduleId);
                if (scheduleData) {
                    scheduleTitle.textContent = scheduleData.name;
                    // Enable copy button
                    createPersonalScheduleBtn.disabled = false;
                    createPersonalScheduleBtn.textContent = 'Copy as Personal Schedule';
                    personalBaseScheduleName.textContent = scheduleData.name;
                    // Enable admin add shared bell
                    if (document.body.classList.contains('admin-mode')) {
                        addSharedBellForm.querySelector('button[type="submit"]').disabled = false;
                    }
                }

                scheduleRef = doc(db, 'artifacts', appId, 'public', 'data', 'schedules', scheduleId);
                activeScheduleListenerUnsubscribe = onSnapshot(scheduleRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const scheduleData = docSnap.data();
                        if (activePersonalScheduleId === null) { // Only update title if a personal schedule isn't active
                            scheduleTitle.textContent = scheduleData.name;
                        }
                        // Apply sound overrides to base schedule bells
                        localSchedule = (scheduleData.bells || []).map(bell => {
                            const overrideKey = getBellOverrideKey(scheduleId, {...bell, type: 'shared'});
                            const overrideSound = bellSoundOverrides[overrideKey];
                            return { 
                                ...bell, 
                                type: 'shared',
                                sound: overrideSound || bell.sound,
                                originalSound: bell.sound
                            };
                        });
                        console.log("Active shared schedule updated.");
                    } else {
                        console.warn("Selected shared schedule does not exist.");
                        localSchedule = [];
                        scheduleTitle.textContent = "Schedule Not Found";
                    }
                    renderCombinedList();
                }, (error) => {
                    console.error("Error on shared schedule snapshot:", error);
                });

            } else if (type === 'personal') {
                console.log("Setting active PERSONAL schedule:", scheduleId);
                activePersonalScheduleId = scheduleId;
                
                const personalSchedule = allPersonalSchedules.find(s => s.id === scheduleId);
                if (!personalSchedule) {
                    console.error("Could not find personal schedule data.");
                    return;
                }

                activeBaseScheduleId = personalSchedule.baseScheduleId;
                scheduleTitle.textContent = personalSchedule.name;
                
                // Enable personal bell form
                personalTimeInput.disabled = false;
                personalNameInput.disabled = false;
                personalSoundInput.disabled = false;
                previewPersonalSoundBtn.disabled = false;
                addPersonalBellForm.querySelector('button[type="submit"]').disabled = false;
                personalBellStatus.textContent = `Adding bells to: ${personalSchedule.name}`;
                deletePersonalScheduleBtn.disabled = false;
                deletePersonalScheduleBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                
                // v3.05: Enable "Duplicate" button
                createPersonalScheduleBtn.disabled = false;
                createPersonalScheduleBtn.textContent = 'Duplicate as Another Personal Schedule';
                
                // v3.05: Enable manager buttons
                renamePersonalScheduleBtn.disabled = false;
                backupPersonalScheduleBtn.disabled = false;
                restorePersonalScheduleBtn.disabled = false;
                
                // 1. Listen to the BASE shared schedule
                scheduleRef = doc(db, 'artifacts', appId, 'public', 'data', 'schedules', activeBaseScheduleId);
                activeScheduleListenerUnsubscribe = onSnapshot(scheduleRef, (docSnap) => {
                    if (docSnap.exists()) {
                        // Apply sound overrides to base schedule bells
                        localSchedule = (docSnap.data().bells || []).map(bell => {
                            const overrideKey = getBellOverrideKey(activeBaseScheduleId, {...bell, type: 'shared'});
                            const overrideSound = bellSoundOverrides[overrideKey];
                            return { 
                                ...bell, 
                                type: 'shared',
                                sound: overrideSound || bell.sound,
                                originalSound: bell.sound
                            };
                        });
                        console.log("Base schedule for personal schedule updated.");
                    } else {
                        console.warn("Base schedule does not exist.");
                        localSchedule = [];
                    }
                    renderCombinedList();
                });
                
                // 2. Listen to the PERSONAL schedule
                const personalScheduleRef = doc(db, 'artifacts', appId, 'users', userId, 'personal_schedules', activePersonalScheduleId);
                activePersonalScheduleListenerUnsubscribe = onSnapshot(personalScheduleRef, (docSnap) => {
                    if (docSnap.exists()) {
                        // Personal bells do not get overrides (they are edited directly)
                        personalBells = (docSnap.data().bells || []).map(bell => ({
                            ...bell,
                            type: 'custom' // This flags them as personal bells for editing
                        }));
                        console.log("Personal schedule bells updated.");
                    } else {
                        console.warn("Personal schedule removed.");
                        personalBells = [];
                        // TODO: Handle if the personal schedule is deleted out from under us
                    }
                    renderCombinedList();
                });
            }
        }


        async function handleCreateSchedule(e) {
            e.preventDefault();
            const name = newScheduleNameInput.value.trim();
            if (!name) return;
            
            try {
                const newDocRef = await addDoc(schedulesCollectionRef, {
                    name: name,
                    bells: [] 
                });
                
                console.log("Schedule created with ID:", newDocRef.id);
                newScheduleNameInput.value = '';
                // MODIFIED: v3.24 - Removed loadSharedSchedules()
                
                scheduleSelector.value = `shared-${newDocRef.id}`; // v3.03 prefix
                setActiveSchedule(scheduleSelector.value);
                
            } catch (error) {
                console.error("Error creating schedule:", error);
            }
        }
        
        /**
         * NEW: v3.02 - Finds all shared bells within 60s of the new time.
         * @param {string} time - The time to check (HH:MM:SS)
         * @param {string} name - The name of the bell to check
         * @returns {object} { internal: bell|null, external: [{schedule, bell}] }
         */
        function findAllNearbySharedBells(time) {
            const newTimeInSeconds = timeToSeconds(time);
            if (isNaN(newTimeInSeconds)) return { internal: null, external: [] };

            let internalConflict = null;
            const externalConflicts = [];

            // MODIFIED: v3.03 - Use activeBaseScheduleId
            const currentSchedule = allSchedules.find(s => s.id === activeBaseScheduleId);

            for (const schedule of allSchedules) {
                // MODIFIED: v3.03 - Use activeBaseScheduleId
                const isCurrentSchedule = schedule.id === activeBaseScheduleId;
                
                // Use findNearbyBell helper, but *only* check bells with the same name
                // This is a modification from the spec, which said *any* bell.
                // Re-reading: "within 60s of an existing bell" - doesn't specify name.
                // Re-reading v3.02 "Conflict in Other Shared Schedules" - "Similar Bell Found"
                // Let's assume the user *meant* to find bells with the *same name* for v3.02,
                // as that's what makes the "Match" and "Create/Match" options logical.
                // If we find bells with different names, matching them makes no sense.
                //
                // **Decision: I will check for bells with the *same name* within 60 seconds.**
                // This aligns with the logic of "linked" bells.
                //
                // UPDATE: The original v3.02 code was checking *any* bell. Let's revert to that
                // to match the spec `specs_v3.02.md` which says "an existing bell", not "an existing
                // bell with the same name".
                //
                // OK, re-reading the v3.02 code I provided, it was `findAllNearbySharedBells(time)`
                // and it did NOT check for name. I will remove the `name` parameter again.

                const bellList = schedule.bells || [];
                for (const bell of bellList) {
                    // DELETED: Name check removed to match spec
                    // if (bell.name !== name) {
                    //     continue;
                    // }

                    const existingTimeInSeconds = timeToSeconds(bell.time);
                    if (isNaN(existingTimeInSeconds)) continue;

                    if (Math.abs(newTimeInSeconds - existingTimeInSeconds) <= 60) {
                        // Conflict found!
                        if (isCurrentSchedule) {
                            if (!internalConflict) { // Only grab the first one
                                internalConflict = bell;
                            }
                        } else {
                            externalConflicts.push({ schedule, bell });
                        }
                    }
                }
            }
            
            // De-duplicate external conflicts based on the bell itself (time and name)
            const uniqueExternal = new Map();
            for (const conflict of externalConflicts) {
                const key = `${conflict.bell.name}::${conflict.bell.time}`;
                if (!uniqueExternal.has(key)) {
                    uniqueExternal.set(key, conflict);
                }
            }

            // ADDED: Missing return statement and closing brace
            return { internal: internalConflict, external: Array.from(uniqueExternal.values()) };
        }

        // --- NEW: v3.05 Personal Schedule Manager Functions ---

        // MODIFIED: v3.26 - Replaced prompt() with custom modal
        function handleRenamePersonalSchedule() {
            if (!activePersonalScheduleId) return;
            const schedule = allPersonalSchedules.find(s => s.id === activePersonalScheduleId);
            if (!schedule) return;

            // Populate modal with current name
            renameOldScheduleName.textContent = schedule.name;
            renameNewScheduleNameInput.value = schedule.name;
            renamePersonalScheduleStatus.classList.add('hidden'); // Clear status
            
            // Show the modal
            renamePersonalScheduleModal.classList.remove('hidden');
        }

        // NEW: v3.26 - Form submission handler for the rename modal
        async function handleRenamePersonalScheduleSubmit(e) {
            e.preventDefault();
            if (!activePersonalScheduleId) return;
            const schedule = allPersonalSchedules.find(s => s.id === activePersonalScheduleId);
            if (!schedule) return;

            const newName = renameNewScheduleNameInput.value.trim();
            
            if (newName && newName !== "" && newName !== schedule.name) {
                renamePersonalScheduleStatus.textContent = "Saving...";
                renamePersonalScheduleStatus.classList.remove('hidden');
                
                const docRef = doc(db, 'artifacts', appId, 'users', userId, 'personal_schedules', activePersonalScheduleId);
                try {
                    await updateDoc(docRef, { name: newName });
                    console.log("Personal schedule renamed.");
                    // The onSnapshot listener will handle the UI update.
                    
                    // Reselect the renamed schedule
                    scheduleSelector.value = `personal-${activePersonalScheduleId}`;
                    setActiveSchedule(scheduleSelector.value);
                    
                    renamePersonalScheduleModal.classList.add('hidden'); // Close modal on success
                } catch (error) {
                    console.error("Error renaming schedule:", error);
                    renamePersonalScheduleStatus.textContent = "Error saving name.";
                }
            } else if (newName === schedule.name) {
                // No change, just close the modal
                renamePersonalScheduleModal.classList.add('hidden');
            } else {
                // Invalid name
                renamePersonalScheduleStatus.textContent = "Please enter a valid name.";
                renamePersonalScheduleStatus.classList.remove('hidden');
            }
        }


        function handleBackupPersonalSchedule() {
            if (!activePersonalScheduleId) return;
            const schedule = allPersonalSchedules.find(s => s.id === activePersonalScheduleId);
            if (!schedule) return;

            // Create a clean backup object
            const backupData = {
                type: "EllisWebBell_PersonalSchedule_v1",
                name: schedule.name,
                baseScheduleId: schedule.baseScheduleId,
                bells: schedule.bells
            };

            try {
                const dataStr = JSON.stringify(backupData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const a = document.createElement('a');
                a.href = url;
                const filename = (schedule.name || 'personal_schedule').replace(/[^a-z0-9]/gi, '_').toLowerCase();
                a.download = `ellisbell_backup_${filename}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                 console.error("Error backing up schedule:", error);
            }
        }
        
        function handleRestoreFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    // Validate
                    if (data.type !== "EllisWebBell_PersonalSchedule_v1" || data.name === undefined || data.baseScheduleId === undefined || !Array.isArray(data.bells)) {
                        throw new Error("Invalid or corrupt backup file.");
                    }
                    pendingRestoreData = data; // Store data
                    
                    const schedule = allPersonalSchedules.find(s => s.id === activePersonalScheduleId);
                    
                    confirmRestoreText.textContent = `Overwrite "${schedule.name}" with data from "${data.name}" (from file ${file.name})? This cannot be undone.`;
                    confirmRestoreModal.classList.remove('hidden');

                } catch (error) {
                    console.error("Restore file read failed:", error);
                } finally {
                    restoreFileInput.value = ''; // Clear input
                }
            };
            reader.readAsText(file);
        }

        async function confirmRestorePersonalSchedule() {
            if (!pendingRestoreData || !activePersonalScheduleId) return;

            const { name, baseScheduleId, bells } = pendingRestoreData;
            const docRef = doc(db, 'artifacts', appId, 'users', userId, 'personal_schedules', activePersonalScheduleId);
            
            try {
                // setDoc will overwrite
                await setDoc(docRef, { name, baseScheduleId, bells });
                console.log("Schedule restored.");
                
                // MODIFIED: v3.09 - No longer need to call loadPersonalSchedules()
                // The listener will handle the update.
                scheduleSelector.value = `personal-${activePersonalScheduleId}`;
                setActiveSchedule(scheduleSelector.value);

            } catch (error) {
                console.error("Error restoring schedule:", error);
            } finally {
                pendingRestoreData = null;
                confirmRestoreModal.classList.add('hidden');
            }
        }

        // --- End v3.05 Functions ---

        
        // DELETED: Removed entire duplicate function block
        /*
         * NEW: v3.02 - Finds all shared bells within 60s of the new time.
         */
        /*
        function findAllNearbySharedBells(time) {
            // ... (code was duplicated) ...
        }
        */

        async function handleAddSharedBell(e) {
            e.preventDefault();
            // MODIFIED: v3.03 - Check activeBaseScheduleId and scheduleRef
            if (!activeBaseScheduleId || !scheduleRef) {
                addSharedStatus.textContent = "Please select a schedule first.";
                addSharedStatus.classList.remove('hidden');
                setTimeout(() => addSharedStatus.classList.add('hidden'), 3000);
                return;
            }
            
            const time = sharedTimeInput.value;
            const name = sharedNameInput.value;
            const sound = sharedSoundInput.value;
            
            if (!time || !name) {
                addSharedStatus.textContent = "Please provide a time and name.";
                addSharedStatus.classList.remove('hidden');
                setTimeout(() => addSharedStatus.classList.add('hidden'), 3000);
                return;
            }

            const newBell = { time, name, sound };
            // MODIFIED: v3.03 - Check activeBaseScheduleId
            const currentSchedule = allSchedules.find(s => s.id === activeBaseScheduleId);
            if (!currentSchedule) {
                console.warn("Could not find current schedule data.");
                return;
            }
            
            const existingBells = currentSchedule.bells || [];

            // --- v3.02 LOGIC START ---

            // Check for *exact* duplicate first
            if (existingBells.find(b => b.time === time && b.name === name)) {
                console.warn("This bell (time and name) already exists in this schedule.");
                addSharedStatus.textContent = "This exact bell already exists.";
                addSharedStatus.classList.remove('hidden');
                setTimeout(() => addSharedStatus.classList.add('hidden'), 3000);
                return;
            }

            // Find all conflicts (internal and external)
            // MODIFIED: v3.02 logic restored - checking *any* bell time
            const conflicts = findAllNearbySharedBells(time);

            // Store pending bell for modals
            pendingSharedBell = newBell;

            // --- Scenario 1: Internal Conflict ---
            if (conflicts.internal) {
                console.log("Scenario 1: Internal Conflict Found", conflicts.internal);
                currentInternalConflict = conflicts.internal; // Store conflict
                
                // Populate and show Initial Warning Modal
                internalConflictNewTime.textContent = formatTime12Hour(time, true); // v3.22
                internalConflictExistingBell.textContent = `${conflicts.internal.name} at ${formatTime12Hour(conflicts.internal.time, true)}`; // v3.22
                internalConflictWarningModal.classList.remove('hidden');
                return; // Stop. Action will resume from modal buttons.
            }

            // --- Scenario 2: External Conflict (and NO internal) ---
            if (conflicts.external.length > 0) {
                console.log("Scenario 2: External Conflict(s) Found", conflicts.external);
                currentExternalConflicts = conflicts.external; // Store conflicts
                
                // Populate and show External Conflict Modal
                externalConflictNewTime.textContent = formatTime12Hour(time, true); // v3.22
                externalConflictKeepTime.textContent = formatTime12Hour(time, true); // v3.22
                
                // Populate list
                externalConflictList.innerHTML = conflicts.external.map(c => {
                    const checkId = `ext-conflict-${c.schedule.id}-${c.bell.time.replace(/:/g, '-')}`;
                    return `
                    <div class="flex items-center">
                        <input type="checkbox" id="${checkId}" 
                               data-schedule-id="${c.schedule.id}"
                               data-bell-time="${c.bell.time}"
                               data-bell-name="${c.bell.name.replace(/"/g, '&quot;')}"
                               class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 external-conflict-check">
                        <label for="${checkId}" class="ml-2 block text-sm text-gray-900">
                            <span class="font-medium">${c.schedule.name}:</span>
                            <span>${c.bell.name} at ${formatTime12Hour(c.bell.time, true)}</span> <!-- v3.22 -->
                        </label>
                    </div>
                `}).join('');
                
                // Update button states (call listener handler)
                handleExternalConflictCheckboxChange();
                externalConflictModal.classList.remove('hidden');
                return; // Stop. Action will resume from modal buttons.
            }

            // --- Case A: No Conflict ---
            console.log("Case A: No conflict found. Adding bell directly.");
            const updatedBells = [...existingBells, newBell];

            try {
                await updateDoc(scheduleRef, { bells: updatedBells });
                
                console.log("Shared bell added.");
                addSharedBellForm.reset();
                addSharedBellForm.elements['shared-bell-sound'].value = 'ellisBell.mp3'; 
                addSharedStatus.textContent = `Bell "${name}" added to ${currentSchedule.name}.`;
                addSharedStatus.classList.remove('hidden');
                setTimeout(() => addSharedStatus.classList.add('hidden'), 3000);
                
            } catch (error) {
                console.error("Error adding shared bell:", error);
                addSharedStatus.textContent = "Error adding bell.";
                addSharedStatus.classList.remove('hidden');
            } finally {
                // Clear any pending state just in case
                closeAllConflictModals();
            }
            // --- v3.02 LOGIC END ---
        }
        
        /**
         * NEW: v3.02 - Helper to add a bell from a pending state (e.g., after modal)
         * This is used by Scenario 1 (Final Confirm) and Scenario 2 (Keep New Time)
         */
        async function addPendingBellToCurrentSchedule() {
            // MODIFIED: v3.03 - Check activeBaseScheduleId
            if (!pendingSharedBell || !activeBaseScheduleId || !scheduleRef) {
                console.error("Missing data for pending bell add.");
                return;
            }

            // MODIFIED: v3.03 - Check activeBaseScheduleId
            const currentSchedule = allSchedules.find(s => s.id === activeBaseScheduleId);
            if (!currentSchedule) {
                console.warn("Could not find current schedule data.");
                return;
            }
            
            const existingBells = currentSchedule.bells || [];
            const newBell = pendingSharedBell; // Get the staged bell

            // Final check for exact duplicate (shouldn't happen, but safe)
            if (existingBells.find(b => b.time === newBell.time && b.name === newBell.name)) {
                console.warn("This bell (time and name) already exists in this schedule.");
                return;
            }
            
            const updatedBells = [...existingBells, newBell];

            try {
                await updateDoc(scheduleRef, { bells: updatedBells });
                
                console.log("Pending shared bell added.");
                addSharedBellForm.reset();
                addSharedBellForm.elements['shared-bell-sound'].value = 'ellisBell.mp3'; 
                addSharedStatus.textContent = `Bell "${newBell.name}" added to ${currentSchedule.name}.`;
                addSharedStatus.classList.remove('hidden');
                setTimeout(() => addSharedStatus.classList.add('hidden'), 3000);
                
            } catch (error) {
                console.error("Error adding pending shared bell:", error);
                addSharedStatus.textContent = "Error adding bell.";
                addSharedStatus.classList.remove('hidden');
            } finally {
                // Clear state and close modals
                closeAllConflictModals();
            }
        }
        
        /**
         * NEW: v3.02 - Resets and closes all conflict modals
         */
        function closeAllConflictModals() {
            internalConflictWarningModal.classList.add('hidden');
            internalConflictConfirmModal.classList.add('hidden');
            externalConflictModal.classList.add('hidden');
            
            // Clear status texts
            externalConflictStatus.classList.add('hidden');
            externalConflictStatus.textContent = '';

            // Clear state
            pendingSharedBell = null;
            currentInternalConflict = null;
            currentExternalConflicts = [];
            
            console.log("Conflict state cleared.");
        }

        /**
         * NEW: v3.02 - Handles Scenario 2 resolutions
         * @param {string} resolutionType - 'match', 'keep', 'create_and_match'
         */
        async function handleExternalConflictResolution(resolutionType) {
            // MODIFIED: v3.03 - Check activeBaseScheduleId
            if (!pendingSharedBell || !activeBaseScheduleId) return;

            const newBell = pendingSharedBell; // The bell we want to create
            const batch = writeBatch(db);
            // MODIFIED: v3.03 - Check activeBaseScheduleId
            const currentSchedule = allSchedules.find(s => s.id === activeBaseScheduleId);

            // Get all checked items
            const checkedCheckboxes = Array.from(externalConflictList.querySelectorAll('.external-conflict-check:checked'));
            const checkedConflicts = checkedCheckboxes.map(cb => {
                const scheduleId = cb.dataset.scheduleId;
                const bellTime = cb.dataset.bellTime;
                const bellName = cb.dataset.bellName;
                // Find the original conflict object
                const source = currentExternalConflicts.find(c => 
                    c.schedule.id === scheduleId && 
                    c.bell.time === bellTime &&
                    c.bell.name === bellName
                );
                return source; // { schedule, bell }
            }).filter(Boolean); // Filter out any undefined

            // Show loading status
            externalConflictStatus.textContent = "Processing...";
            externalConflictStatus.classList.remove('hidden');
            
            // Disable all buttons
            externalConflictMatchBtn.disabled = true;
            externalConflictKeepBtn.disabled = true;
            externalConflictCreateAndMatchBtn.disabled = true;
            externalConflictCancelBtn.disabled = true;

            try {
                if (resolutionType === 'keep') {
                    // This is simple: just add it to the current schedule.
                    // The addPendingBellToCurrentSchedule function handles this.
                    await addPendingBellToCurrentSchedule(); // This closes modals and clears state
                    return; // Done
                
                } else if (resolutionType === 'match') {
                    if (checkedConflicts.length !== 1) return; // Should be impossible
                    
                    const bellToMatch = checkedConflicts[0].bell;
                    // Per spec: "sets its time to match the *selected* bell's time"
                    // We keep the new bell's name and sound.
                    const bellToAdd = {
                        ...newBell, 
                        time: bellToMatch.time // But use existing time
                    };

                    const updatedBells = [...currentSchedule.bells, bellToAdd];
                    // MODIFIED: v3.03 - Use activeBaseScheduleId
                    const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'schedules', activeBaseScheduleId);
                    batch.update(docRef, { bells: updatedBells });
                    
                    await batch.commit();
                    externalConflictStatus.textContent = "Bell added, matching existing time.";

                } else if (resolutionType === 'create_and_match') {
                    if (checkedConflicts.length === 0) return; // Should be impossible

                    // 1. Add the new bell to THIS schedule
                    const currentScheduleBells = [...currentSchedule.bells, newBell];
                    // MODIFIED: v3.03 - Use activeBaseScheduleId
                    const currentDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'schedules', activeBaseScheduleId);
                    batch.update(currentDocRef, { bells: currentScheduleBells });

                    // 2. Update all CHECKED external schedules
                    for (const { schedule, bell: originalBellToReplace } of checkedConflicts) {
                        
                        // Find and replace the original bell with the new one
                        // Per spec: "updates all *checked* bells... to use this `NewTime`"
                        // This implies we are only changing the *time* of the existing bells,
                        // not their name or sound.
                        const newTime = newBell.time;
                        
                        const updatedBells = schedule.bells.map(b => 
                            (b.time === originalBellToReplace.time && b.name === originalBellToReplace.name) 
                            ? { ...b, time: newTime } // Keep old name/sound, update time
                            : b
                        );
                        
                        // Clear any local overrides for the bell we are replacing
                        const overrideKey = getBellOverrideKey(schedule.id, originalBellToReplace);
                        if (overrideKey && bellSoundOverrides[overrideKey]) {
                            delete bellSoundOverrides[overrideKey];
                        }
                        
                        // Set the update in the batch
                        const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'schedules', schedule.id);
                        batch.update(docRef, { bells: updatedBells });
                    }
                    
                    saveSoundOverrides(); // Save any override deletions
                    await batch.commit();
                    externalConflictStatus.textContent = `Bell created and ${checkedConflicts.length} other schedules updated.`;
                }

                // For 'match' and 'create_and_match', we need to reset and close
                // MODIFIED: v3.24 - Removed loadSharedSchedules()
                addSharedBellForm.reset();
                addSharedBellForm.elements['shared-bell-sound'].value = 'ellisBell.mp3'; 
                setTimeout(() => {
                    closeAllConflictModals();
                }, 2000); // Give user time to read status

            } catch (error) {
                console.error(`Error in ${resolutionType} resolution:`, error);
                externalConflictStatus.textContent = `An error occurred: ${error.message}`;
                // Re-enable cancel btn on error
                externalConflictCancelBtn.disabled = false;
            }
        }
        
        /**
         * NEW: v3.02 - Updates Scenario 2 modal button states based on checkboxes
         */
        function handleExternalConflictCheckboxChange() {
            const checkedCheckboxes = Array.from(externalConflictList.querySelectorAll('.external-conflict-check:checked'));
            
            // "Match Existing" - enabled if exactly 1 is checked
            if (checkedCheckboxes.length === 1) {
                externalConflictMatchBtn.disabled = false;
                const time = checkedCheckboxes[0].dataset.bellTime;
                externalConflictMatchTime.textContent = formatTime12Hour(time, true); // v3.22
            } else {
                externalConflictMatchBtn.disabled = true;
                externalConflictMatchTime.textContent = "--:--";
            }

            // "Create and Match" - enabled if 1 or more is checked
            if (checkedCheckboxes.length > 0) {
                externalConflictCreateAndMatchBtn.disabled = false;
            } else {
                externalConflictCreateAndMatchBtn.disabled = true;
            }
        }

        async function handleDeleteSchedule() {
            // MODIFIED: v3.03 - activeScheduleId is now activeBaseScheduleId
            const scheduleIdToDelete = activeBaseScheduleId;
            if (!scheduleIdToDelete) {
                console.warn("No active shared schedule to delete.");
                return;
            }
            
            const scheduleName = allSchedules.find(s => s.id === scheduleIdToDelete)?.name;
            if (!scheduleName) {
                console.warn("Could not find schedule name to delete.");
                return;
            }
            
            confirmDeleteText.textContent = `Are you sure you want to delete "${scheduleName}"? This cannot be undone.`;
            confirmDeleteModal.classList.remove('hidden');
        }
        
        async function confirmDeleteSchedule() {
            // MODIFIED: v3.03 - use activeBaseScheduleId
            if (!activeBaseScheduleId) return;
            
            const scheduleIdToDelete = activeBaseScheduleId;
            const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'schedules', scheduleIdToDelete);

            try {
                await deleteDoc(docRef);
                console.log("Schedule deleted:", scheduleIdToDelete);
                activeBaseScheduleId = null;
                localSchedule = [];
                // MODIFIED: v3.24 - Removed loadSharedSchedules()
            } catch (error) {
                console.error("Error deleting schedule:", error);
            }
            
            confirmDeleteModal.classList.add('hidden');
        }

        // --- Event Delegation for Bell List ---
        function handleBellListClick(e) {
            const target = e.target;

            if (target.classList.contains('bell-mute-toggle')) {
                const bellId = target.dataset.bellId;
                if (!bellId) return;
                
                if (target.checked) {
                    mutedBellIds.add(bellId);
                } else {
                    mutedBellIds.delete(bellId);
                }
                saveMutedBells();
                updateClock(); 
                return; 
            }
            
            // NEW: v3.19 - Handle Play Button
            if (target.classList.contains('preview-bell-btn')) {
                const bellElement = target.closest('[data-time]');
                if (bellElement) {
                    const soundToPlay = bellElement.dataset.sound;
                    if (soundToPlay) {
                        playBell(soundToPlay);
                    }
                }
                return; // Stop processing
            }

            const bellElement = target.closest('[data-time]');
            if (!bellElement) return;

            const bell = {
                time: bellElement.dataset.time,
                name: bellElement.dataset.name,
                sound: bellElement.dataset.sound,
                type: bellElement.dataset.type,
                originalSound: bellElement.dataset.originalSound
            };

            if (target.classList.contains('delete-btn') || target.classList.contains('delete-custom-btn')) {
                handleDeleteBellClick(bell.time, bell.name, bell.type);
            } else if (target.classList.contains('edit-btn') || target.classList.contains('edit-custom-btn')) {
                handleEditBellClick(bell.time, bell.name, bell.sound, bell.type);
            } else if (target.classList.contains('sound-btn')) { // NEW: Handle sound button
                openChangeSoundModal(bell);
            }
        }

        function handleDeleteBellClick(time, name, type) {
            bellToDelete = { time, name, type };
            confirmDeleteBellText.textContent = `Are you sure you want to delete the bell "${name}" at ${formatTime12Hour(time, true)}?`; // v3.22
            confirmDeleteBellModal.classList.remove('hidden');
        }
        
        async function confirmDeleteBell() {
            if (!bellToDelete) return;
            
            const { time, name, type } = bellToDelete;
            
            const bellId = getBellId(bellToDelete);
            if (mutedBellIds.has(bellId)) {
                mutedBellIds.delete(bellId);
                saveMutedBells();
            }
            
            // NEW: Delete any sound overrides for this bell
            // MODIFIED: v3.03 - Use activeBaseScheduleId
            const overrideKey = getBellOverrideKey(activeBaseScheduleId, bellToDelete);
            if (overrideKey && bellSoundOverrides[overrideKey]) {
                delete bellSoundOverrides[overrideKey];
                saveSoundOverrides();
            }

            if (type === 'custom') {
                // MODIFIED: v3.03 - Delete from Firestore personal schedule
                if (!activePersonalScheduleId) return;
                const personalScheduleRef = doc(db, 'artifacts', appId, 'users', userId, 'personal_schedules', activePersonalScheduleId);
                try {
                    const docSnap = await getDoc(personalScheduleRef);
                    if (!docSnap.exists()) return;
                    const existingBells = docSnap.data().bells || [];
                    const updatedBells = existingBells.filter(b => !(b.time === time && b.name === name));
                    await updateDoc(personalScheduleRef, { bells: updatedBells });
                    console.log("Personal bell deleted.");
                } catch (error) {
                    console.error("Error deleting personal bell:", error);
                }
            } else if (type === 'shared') {
                // MODIFIED: v3.03 - Use activeBaseScheduleId
                const currentSchedule = allSchedules.find(s => s.id === activeBaseScheduleId);
                if (!currentSchedule) {
                    console.warn("Error: Could not find active schedule.");
                    return;
                }
                
                const updatedBells = currentSchedule.bells.filter(b => !(b.time === time && b.name === name));
                
                try {
                    // MODIFIED: v3.03 - scheduleRef is already set to the base schedule
                    await updateDoc(scheduleRef, { bells: updatedBells });
                    console.log("Shared bell deleted.");
                } catch (error) {
                    console.error("Error deleting shared bell:", error);
                }
            }
            
            confirmDeleteBellModal.classList.add('hidden');
            bellToDelete = null;
        }
        
        // --- Edit Bell Logic (Admin) ---
        function handleEditBellClick(time, name, sound, type) {
            currentEditingBell = { 
                time, 
                name, 
                sound, 
                type, 
                originalTime: time, 
                originalName: name
            };
            
            editBellTimeInput.value = time;
            editBellNameInput.value = name;
            editBellSoundInput.value = sound; // This might be a URL
            
            editBellModal.classList.remove('hidden');
        }

        // NEW: v3.25 - Helper function to execute the update for a personal bell
        async function executePersonalBellUpdate(originalBell, newBellData) {
            const { originalTime, originalName } = originalBell;
            
            if (!activePersonalScheduleId) {
                console.error("No active personal schedule to update.");
                return;
            }
            
            const personalScheduleRef = doc(db, 'artifacts', appId, 'users', userId, 'personal_schedules', activePersonalScheduleId);
            try {
                const docSnap = await getDoc(personalScheduleRef);
                if (!docSnap.exists()) return;
                
                const existingBells = docSnap.data().bells || [];
                const updatedBells = existingBells.map(b => 
                    (b.time === originalTime && b.name === originalName) ? newBellData : b
                );
                
                await updateDoc(personalScheduleRef, { bells: updatedBells });
                console.log("Personal bell updated.");
            } catch (error) {
                console.error("Error updating personal bell:", error);
            }
        }

        // NEW: v3.25 - Helper function to run after "confirm" on nearby modal
        async function updatePendingPersonalBell() {
            if (!pendingPersonalBell || !pendingPersonalBellOriginal || !activePersonalScheduleId) {
                console.error("Missing data for pending personal bell update.");
                return;
            }
            
            const newBellData = {
                time: pendingPersonalBell.time,
                name: pendingPersonalBell.name,
                sound: pendingPersonalBell.sound
            };
            
            await executePersonalBellUpdate(pendingPersonalBellOriginal, newBellData);
            closeNearbyBellModal();
        }

        // NEW: v3.25 - Central handler for the "Confirm" button on the nearby bell modal
        async function confirmPendingPersonalBellAction() {
            if (pendingPersonalBellAction === 'add') {
                await executeAddPersonalBell();
            } else if (pendingPersonalBellAction === 'edit') {
                await updatePendingPersonalBell();
            }
        }

        // MODIFIED: v3.25 - Updated to use nearby bell modal for personal edits
        async function handleEditBellSubmit(e) {
            e.preventDefault();
            if (!currentEditingBell) return;

            const newBellData = {
                time: editBellTimeInput.value,
                name: editBellNameInput.value,
                sound: editBellSoundInput.value
            };
            
            const { originalTime, originalName, type, sound: originalSound } = currentEditingBell;

            // REQ 1 (Applied to Edits): Check for nearby bells *before* saving
            const allBells = [...localSchedule, ...personalBells];
            const excludeBell = { time: originalTime, name: originalName };
            const nearbyBell = findNearbyBell(newBellData.time, allBells, excludeBell);

            // Clear old mute ID if it exists
            const oldBellId = getBellId({type, time: originalTime, name: originalName});
            if (mutedBellIds.has(oldBellId)) {
                mutedBellIds.delete(oldBellId);
                saveMutedBells();
            }

            if (type === 'custom') {
                // MODIFIED: v3.25 - Check for nearby bell on edit
                if (nearbyBell) {
                    // Show the nearby bell modal and stop
                    pendingPersonalBell = { ...newBellData, type: 'custom' };
                    pendingPersonalBellAction = 'edit';
                    pendingPersonalBellOriginal = currentEditingBell;
                    
                    nearbyBellName.textContent = nearbyBell.name;
                    nearbyBellTime.textContent = formatTime12Hour(nearbyBell.time, true);
                    nearbyBellCustomControls.style.display = 'flex';
                    nearbyBellModal.classList.remove('hidden');
                    
                    closeEditBellModal(); // Close the edit modal
                    return; // Stop here, modal handler will take over
                } else {
                    // No conflict, update directly
                    await executePersonalBellUpdate({ originalTime, originalName }, newBellData);
                    closeEditBellModal();
                }

            } else if (type === 'shared') {
                // This is the bell we are matching against in other schedules
                const originalBellForSearch = { time: originalTime, name: originalName, sound: originalSound };
                
                const linkedSchedules = findLinkedSchedules(originalBellForSearch);
                // MODIFIED: v3.03 - Use activeBaseScheduleId
                const otherLinkedSchedules = linkedSchedules.filter(s => s.id !== activeBaseScheduleId);

                if (otherLinkedSchedules.length > 0) {
                    linkedEditData = {
                        originalBell: originalBellForSearch, // The bell as it was
                        newBellData, // The new data
                        linkedSchedules: otherLinkedSchedules // Array of {id, name, bell}
                    };
                    renderLinkedScheduleList(otherLinkedSchedules);
                    confirmLinkedEditModal.classList.remove('hidden');
                } else {
                    // No other schedules, just update this one
                    // MODIFIED: v3.03 - Use activeBaseScheduleId
                    await updateBellInSchedules(originalBellForSearch, newBellData, [activeBaseScheduleId]);
                    closeEditBellModal();
                }
            }
        }

        // --- NEW: Change Sound Logic (All Users) ---
        function openChangeSoundModal(bell) {
            currentChangingSoundBell = bell;
            changeSoundBellName.textContent = bell.name;
            changeSoundBellTime.textContent = formatTime12Hour(bell.time, true); // v3.22
            // Set dropdown to the *current* sound (which might be an override)
            changeSoundSelect.value = bell.sound;
            changeSoundModal.classList.remove('hidden');
        }

        function handleChangeSoundSubmit(e) {
            e.preventDefault();
            if (!currentChangingSoundBell) return;

            const newSound = changeSoundSelect.value;
            const originalSound = currentChangingSoundBell.originalSound || currentChangingSoundBell.sound;
            // MODIFIED: v3.03 - Use activeBaseScheduleId
            const overrideKey = getBellOverrideKey(activeBaseScheduleId, currentChangingSoundBell);

            if (!overrideKey) {
                console.error("Could not generate override key.");
                return;
            }

            if (newSound === originalSound) {
                // If user selected the original sound, remove the override
                delete bellSoundOverrides[overrideKey];
                console.log("Removed sound override.");
            } else {
                // Otherwise, add/update the override
                bellSoundOverrides[overrideKey] = newSound;
                console.log("Set sound override:", newSound);
            }

            saveSoundOverrides();
            
            // Re-apply overrides to the in-memory localSchedule
            // MODIFIED: v3.03 - Use activeBaseScheduleId
            const schedule = allSchedules.find(s => s.id === activeBaseScheduleId);
            if(schedule) {
                 localSchedule = (schedule.bells || []).map(bell => ({
                    ...bell,
                    type: 'shared' 
                })).map(bell => {
                    // MODIFIED: v3.03 - Use activeBaseScheduleId
                    const key = getBellOverrideKey(activeBaseScheduleId, bell);
                    const override = bellSoundOverrides[key];
                    if (override) {
                        return { ...bell, sound: override, originalSound: bell.sound };
                    }
                    // MODIFIED: v3.25 - Need to set originalSound even if not overridden
                    return { ...bell, originalSound: bell.sound };
                });
            }
            
            renderCombinedList(); // Re-render the list with new override
            closeChangeSoundModal();
        }
        
        function closeChangeSoundModal() {
            changeSoundModal.classList.add('hidden');
            currentChangingSoundBell = null;
        }


        // --- Linked Edit Logic (Admin) ---
        function findLinkedSchedules(bellToFind) {
            // REQ 2: Find by name and time proximity
            const { time: originalTime, name: originalName } = bellToFind;
            const originalTimeInSeconds = timeToSeconds(originalTime);
            const linked = [];
            
            if (isNaN(originalTimeInSeconds)) {
                console.error("Invalid original time for linked edit search.");
                return [];
            }
            
            for (const schedule of allSchedules) {
                // Find any bell in this schedule that matches
                const foundBell = schedule.bells.find(b => {
                    if (b.name !== originalName) return false;
                    const existingTimeInSeconds = timeToSeconds(b.time);
                    if (isNaN(existingTimeInSeconds)) return false;
                    
                    // Check for time proximity
                    return Math.abs(originalTimeInSeconds - existingTimeInSeconds) <= 60;
                });
                
                if (foundBell) {
                    linked.push({ id: schedule.id, name: schedule.name, bell: foundBell }); // Store the actual bell found
                }
            }
            return linked;
        }


        function renderLinkedScheduleList(schedules) {
            if (schedules.length === 0) {
                linkedScheduleList.innerHTML = '<p class="text-gray-500">No other schedules found.</p>';
                return;
            }
            linkedScheduleList.innerHTML = schedules.map(s => `
                <div class="flex items-center">
                    <input type="checkbox" id="linked-${s.id}" value="${s.id}" checked 
                           class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 linked-schedule-check">
                    <label for="linked-${s.id}" class="ml-2 block text-sm text-gray-900">${s.name} (bell at ${formatTime12Hour(s.bell.time, true)})</label> <!-- v3.22 -->
                </div>
            `).join('');
        }

        async function handleLinkedEdit(applyToAll) {
            if (!linkedEditData) return;
            
            const { originalBell, newBellData } = linkedEditData;
            // MODIFIED: v3.03 - Use activeBaseScheduleId
            let scheduleIdsToUpdate = [activeBaseScheduleId]; 
            
            if (applyToAll) {
                const checkedSchedules = Array.from(document.querySelectorAll('.linked-schedule-check:checked'))
                                             .map(cb => cb.value);
                scheduleIdsToUpdate.push(...checkedSchedules);
            }
            
            linkedEditStatus.textContent = "Applying updates...";
            linkedEditStatus.classList.remove('hidden');

            try {
                // REQ 2: Pass the originalBell (with name and time) to the update function
                await updateBellInSchedules(originalBell, newBellData, scheduleIdsToUpdate);
                console.log("Linked update complete.");
            } catch (error) {
                console.error("Linked update failed:", error);
            }
            
            closeLinkedEditModal();
            closeEditBellModal();
        }

        async function updateBellInSchedules(originalBell, newBellData, scheduleIds) {
            const batch = writeBatch(db);
            const uniqueScheduleIds = [...new Set(scheduleIds)];
            
            // REQ 2: Use the original time and name to find bells
            const { time: originalTime, name: originalName } = originalBell;
            const originalTimeInSeconds = timeToSeconds(originalTime);

            for (const scheduleId of uniqueScheduleIds) {
                const schedule = allSchedules.find(s => s.id === scheduleId);
                if (!schedule) continue;

                let bellWasUpdated = false;
                const updatedBells = schedule.bells.map(bell => {
                    // Find the bell(s) to update
                    const existingTimeInSeconds = timeToSeconds(bell.time);
                    if (bell.name === originalName && !isNaN(existingTimeInSeconds) && Math.abs(existingTimeInSeconds - originalTimeInSeconds) <= 60) {
                        
                        // Clear mute for the old bell ID
                        const oldBellId = getBellId({type: 'shared', time: bell.time, name: bell.name});
                        if (mutedBellIds.has(oldBellId)) {
                            mutedBellIds.delete(oldBellId);
                        }
                        // Clear sound override for the old bell
                        const overrideKey = getBellOverrideKey(scheduleId, bell);
                        if (overrideKey && bellSoundOverrides[overrideKey]) {
                            delete bellSoundOverrides[overrideKey];
                        }

                        bellWasUpdated = true;
                        // Return the new bell data, preserving original sound IF new data doesn't have one
                        // This is crucial: edit modal *always* provides a sound.
                        return newBellData; 
                    }
                    return bell;
                });

                if (bellWasUpdated) {
                    const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'schedules', scheduleId);
                    batch.update(docRef, { bells: updatedBells });
                }
            }
            
            // Save local storage changes
            saveMutedBells();
            saveSoundOverrides();

            await batch.commit();
            // MODIFIED: v3.24 - Removed loadSharedSchedules()
        }
        
        function closeEditBellModal() {
            editBellModal.classList.add('hidden');
            currentEditingBell = null;
            editBellForm.reset();
        }
        
        function closeLinkedEditModal() {
            confirmLinkedEditModal.classList.add('hidden');
            linkedEditData = null;
            linkedScheduleList.innerHTML = '';
            linkedEditStatus.classList.add('hidden');
        }


        // --- Multi-Add Bell Modal Logic ---
        function showMultiAddModal() {
            if (allSchedules.length === 0) {
                multiScheduleListContainer.innerHTML = '<p class="text-gray-500">No schedules found. Create one first.</p>';
            } else {
                multiScheduleListContainer.innerHTML = allSchedules.map(s => `
                    <div class="flex items-center">
                        <input type="checkbox" id="multi-${s.id}" value="${s.id}" 
                               class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 multi-schedule-check">
                        <label for="multi-${s.id}" class="ml-2 block text-sm text-gray-900">${s.name}</label>
                    </div>
                `).join('');
            }
            addBellModal.classList.remove('hidden');
        }

        async function handleMultiAddSubmit(e) {
            e.preventDefault();
            
            const newBell = {
                time: multiBellTimeInput.value,
                name: multiBellNameInput.value,
                sound: multiBellSoundInput.value
            };
            
            if (!newBell.time || !newBell.name) {
                console.warn("Please provide a time and name.");
                return;
            }

            const checkedScheduleIds = Array.from(document.querySelectorAll('.multi-schedule-check:checked'))
                                             .map(cb => cb.value);
            
            if (checkedScheduleIds.length === 0) {
                console.warn("Please select at least one schedule.");
                return;
            }
            
            multiAddStatus.textContent = `Adding bell to ${checkedScheduleIds.length} schedule(s)...`;
            multiAddStatus.classList.remove('hidden');
            multiAddSubmitBtn.disabled = true;

            const batch = writeBatch(db);
            let errors = 0;
            let skipped = 0;

            for (const scheduleId of checkedScheduleIds) {
                const schedule = allSchedules.find(s => s.id === scheduleId);
                if (!schedule) {
                    errors++;
                    continue;
                }
                
                // REQ 1 & 3: Check for nearby bells before adding
                // Note: We are checking *any* bell, not just same name
                const nearbyBell = findNearbyBell(newBell.time, schedule.bells);
                if (nearbyBell) {
                    // For multi-add, we'll just skip and warn the user.
                    console.warn(`Skipping add for "${schedule.name}": Nearby bell found (${nearbyBell.name} @ ${nearbyBell.time})`);
                    skipped++;
                    continue;
                }
                
                const bellExists = schedule.bells.find(b => b.time === newBell.time && b.name === newBell.name);
                if (!bellExists) {
                    const updatedBells = [...schedule.bells, newBell];
                    const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'schedules', scheduleId);
                    batch.update(docRef, { bells: updatedBells });
                }
            }

            try {
                await batch.commit();
                let statusMsg = `Successfully added bell to ${checkedScheduleIds.length - errors - skipped} schedule(s).`;
                if (skipped > 0) {
                    statusMsg += ` Skipped ${skipped} due to nearby bells.`;
                }
                multiAddStatus.textContent = statusMsg;

                // MODIFIED: v3.24 - Removed loadSharedSchedules()
                
                multiBellTimeInput.value = '';
                multiBellNameInput.value = '';
                multiBellSoundInput.value = 'ellisBell.mp3'; 
                
                document.querySelectorAll('.multi-schedule-check:checked').forEach(cb => cb.checked = false);

                setTimeout(() => {
                   multiAddStatus.classList.add('hidden');
                }, 4000); // Longer timeout to read message
 
            } catch (error) {
                console.error("Error in multi-add batch:", error);
                multiAddStatus.textContent = "An error occurred.";
            } finally {
                multiAddSubmitBtn.disabled = false;
            }
        }

       // --- Auth Functions (Popup Flow) ---
       async function signInWithGoogle() {
           try {
                await startAudio(); 
                if (!auth) await initFirebase();
                const provider = new GoogleAuthProvider();
                await signInWithPopup(auth, provider);
           } catch (error) {
               console.error("Google Sign-In Error:", error);
                if (error.code !== 'auth/popup-closed-by-user') {
                    statusElement.textContent = "Error signing in. Please try again.";
                }
           }
       }

       async function signInAnon() {
            try {
                await startAudio();
                if (!auth) await initFirebase();
                await signInAnonymously(auth);
            } catch (error) {
                console.error("Anonymous Sign-In Error:", error);
                statusElement.textContent = "Error signing in. Please try again.";
            }
       }


       async function signOutUser() {
           try {
               await signOut(auth);
           } catch (error) {
               console.error("Sign Out Error:", error);
           }
       }


        // --- Admin Mode ---
        function toggleAdminMode() {
            document.body.classList.toggle('admin-mode');
            if (document.body.classList.contains('admin-mode')) {
                adminToggleBtn.textContent = 'Exit Admin';
            } else {
                adminToggleBtn.textContent = 'Toggle Admin';
            }
            // NEW: Re-render audio list to show/hide admin controls
            renderAudioFileManager();
            renderCombinedList(); // NEW: Re-render list to show/hide admin buttons
            // NEW: v3.03 - Re-check admin-related button states
            setActiveSchedule(scheduleSelector.value);
        }
        
        // --- Import/Export Logic ---
        function handleExportSchedules() {
            if (allSchedules.length === 0) {
                console.warn("No schedules to export.");
                return;
            }
            const schedulesToExport = allSchedules.map(s => ({
                name: s.name,
                bells: s.bells
            }));
            const data = {
                appId: appId,
                exportedAt: new Date().toISOString(),
                schedules: schedulesToExport
            };
            const jsonString = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `school-bell-schedules-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function handleImportSchedules() {
            importFileInput.click();
        }

        async function handleFileInputChange(e) {
            const file = e.target.files[0];
            if (!file) return;
            importStatus.textContent = "Reading file...";
            importStatus.classList.remove('hidden');
            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    if (data.appId !== appId) {
                        throw new Error(`Invalid file: App ID mismatch. Expected '${appId}'.`);
                    }
                    if (!data.schedules || !Array.isArray(data.schedules)) {
                        throw new Error("Invalid file: 'schedules' array not found.");
                    }
                    importStatus.textContent = `Found ${data.schedules.length} schedules. Importing...`;
                    const batch = writeBatch(db);
                    let newCount = 0;
                    let updatedCount = 0;
                    for (const scheduleToImport of data.schedules) {
                        const { name, bells } = scheduleToImport;
                        if (!name) continue;
                        const existingSchedule = allSchedules.find(s => s.name === name);
                        const scheduleData = { name: name, bells: bells || [] };
                        if (existingSchedule) {
                            const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'schedules', existingSchedule.id);
                            batch.update(docRef, scheduleData);
                            updatedCount++;
                        } else {
                            const newDocRef = doc(collection(schedulesCollectionRef));
                            batch.set(newDocRef, scheduleData);
                            newCount++;
                        }
                    }
                    await batch.commit();
                    importStatus.textContent = `Import complete! Added: ${newCount}, Updated: ${updatedCount}.`;
                    // MODIFIED: v3.24 - Removed loadSharedSchedules()
                } catch (error) {
                    console.error("Import failed:", error);
                    importStatus.textContent = `Error: ${error.message}`;
                } finally {
                    importFileInput.value = ''; 
                }
            };
            reader.readAsText(file);
        }

        // --- NEW: Audio File Management ---

        function handleFileSelected(e) {
            const file = e.target.files[0];
            if (!file) {
                audioFileName.textContent = "No file chosen.";
                audioUploadBtn.disabled = true;
                fileToUpload = null;
                return;
            }

            // Check file size
            if (file.size > MAX_FILE_SIZE) {
                audioFileName.textContent = `File is too large (${(file.size / 1024 / 1024).toFixed(1)}MB). Max 1MB.`;
                audioFileName.classList.add('text-red-600');
                audioUploadBtn.disabled = true;
                fileToUpload = null;
                return;
            }

            // File is valid
            fileToUpload = file;
            audioFileName.textContent = file.name;
            audioFileName.classList.remove('text-red-600');
            audioUploadBtn.disabled = false;
        }

        async function handleAudioUpload() {
            if (!fileToUpload || isUserAnonymous || !userId) {
                console.error("No file or user not logged in.");
                return;
            }

            audioUploadBtn.disabled = true;
            audioUploadStatus.textContent = `Uploading ${fileToUpload.name}...`;
            audioUploadStatus.classList.remove('hidden');

            try {
                const storageRef = ref(storage, `sounds/users/${userId}/${fileToUpload.name}`);
                
                // MODIFIED: v3.29 - Add contentType to fix octet-stream issue
                const metadata = {
                    // Set the correct Content-Type (e.g., 'audio/mpeg')
                    contentType: fileToUpload.type, 
                    
                    // Keep existing custom metadata
                    customMetadata: {
                        'owner': userId,
                        'ownerEmail': auth.currentUser.email || 'unknown'
                    }
                };
                
                // Upload the file with the new, complete metadata
                await uploadBytes(storageRef, fileToUpload, metadata);

                audioUploadStatus.textContent = "Upload successful! Refreshing list...";
                fileToUpload = null;
                audioUploadInput.value = ''; // Clear file input
                audioFileName.textContent = "No file chosen.";

                await loadAllAudioFiles(); // Refresh lists
                setTimeout(() => audioUploadStatus.classList.add('hidden'), 3000);

            } catch (error) {
                console.error("Audio upload failed:", error);
                audioUploadStatus.textContent = `Upload failed: ${error.message}`;
            } finally {
                audioUploadBtn.disabled = false;
            }
        }
        
        async function loadAllAudioFiles() {
            // 1. Load User's Private Files
            if (!isUserAnonymous && userId) {
                myAudioFilesList.innerHTML = '<p class="text-gray-500">Loading my sounds...</p>';
                const userFolderRef = ref(storage, `sounds/users/${userId}`);
                try {
                    const userFilesResult = await listAll(userFolderRef);
                    userAudioFiles = await Promise.all(userFilesResult.items.map(async (itemRef) => {
                        const url = await getDownloadURL(itemRef);
                        return { name: itemRef.name, url: url, path: itemRef.fullPath };
                    }));
                } catch (e) { 
                    console.error("Error loading user files:", e); 
                    userAudioFiles = []; // Ensure it's an array
                }
            } else {
                userAudioFiles = []; // Not logged in, no private files
            }

            // 2. Load Public/Shared Files
            sharedAudioFilesList.innerHTML = '<p class="text-gray-500">Loading shared sounds...</p>';
            const publicFolderRef = ref(storage, 'sounds/public');
            try {
                const publicFilesResult = await listAll(publicFolderRef);
                sharedAudioFiles = await Promise.all(publicFilesResult.items.map(async (itemRef) => {
                    const url = await getDownloadURL(itemRef);
                    // Get metadata to see who the owner is
                    const meta = await getMetadata(itemRef);
                    const owner = meta.customMetadata?.ownerEmail || 'unknown';
                    return { name: itemRef.name, url: url, path: itemRef.fullPath, owner: owner };
                }));
            } catch (e) { 
                console.error("Error loading shared files:", e); 
                sharedAudioFiles = []; // Ensure it's an array
            }
            
            // NEW: v3.26 - Prune stale entries from synth cache
            try {
                // Create a set of all valid URLs from the file lists
                const validUrls = new Set([...userAudioFiles.map(f => f.url), ...sharedAudioFiles.map(f => f.url)]);
                
                // Get all cached URLs, but EXCLUDE the built-in 'ellisBell.mp3'
                const cachedUrls = Object.keys(synths).filter(url => url.startsWith('http') && url !== 'ellisBell.mp3');
                
                let clearedCount = 0;
                for (const url of cachedUrls) {
                    if (!validUrls.has(url)) {
                        // This cached URL is no longer in Firebase Storage
                        delete synths[url];
                        clearedCount++;
                    }
                }
                if (clearedCount > 0) {
                    console.log(`Cleared ${clearedCount} stale audio file(s) from cache.`);
                }

                // NEW: v3.26 - Check Quick Bell sound against valid URLs
                // Only check if it's a custom sound URL
                if (quickBellSound.startsWith('http') && !validUrls.has(quickBellSound)) {
                    console.log("Resetting Quick Bell sound from stale cache (file no longer exists).");
                    quickBellSound = 'ellisBell.mp3';
                    if (quickBellSoundSelect) { // Ensure select exists
                        quickBellSoundSelect.value = 'ellisBell.mp3';
                    }
                }
            } catch (e) {
                console.error("Error during cache pruning:", e);
            }

            // 3. Render the lists
            renderAudioFileManager();
            updateSoundDropdowns();
        }
        
        function renderAudioFileManager() {
            // Render My Files
            if (userAudioFiles.length === 0) {
                myAudioFilesList.innerHTML = '<p class="text-gray-500">You have not uploaded any audio files.</p>';
            } else {
                myAudioFilesList.innerHTML = userAudioFiles.map(file => {
                    // Check if this file has already been shared
                    const isShared = sharedAudioFiles.some(sharedFile => sharedFile.name === file.name);
                    return `
                    <div class="flex flex-col sm:flex-row justify-between sm:items-center p-2 rounded-lg hover:bg-gray-100">
                        <span class="text-gray-800 truncate" title="${file.name}">${file.name}</span>
                        <div class="flex-shrink-0 flex items-center space-x-2 mt-2 sm:mt-0">
                            <!-- MODIFIED: Replaced checkbox with button/span -->
                            ${isShared ? 
                                '<span class="text-xs font-medium text-green-600 w-20 text-center">(Published)</span>' : 
                                `<button 
                                    class="make-public-btn admin-only text-xs px-2 py-1 bg-blue-500 text-white rounded-lg hover:bg-blue-600 w-20" 
                                    data-path="${file.path}" 
                                    data-name="${file.name}">
                                    Make Public
                                 </button>`
                            }
                            <!-- MODIFIED: v3.27 - Adjusted padding and text size -->
                            <button class="preview-audio-btn px-3 py-1 text-sm bg-gray-200 rounded-lg hover:bg-gray-300" data-url="${file.url}" aria-label="Play">&#9654;</button>
                            <button class="delete-audio-btn text-xs px-2 py-1 bg-red-500 text-white rounded-lg hover:bg-red-600" data-path="${file.path}" data-url="${file.url}">Delete</button>
                        </div>
                    </div>
                    `;
                }).join('');
            }
            
            // Render Shared Files
            if (sharedAudioFiles.length === 0) {
                sharedAudioFilesList.innerHTML = '<p class="text-gray-500">No shared audio files are available.</p>';
            } else {
                sharedAudioFilesList.innerHTML = sharedAudioFiles.map(file => `
                    <div class="flex flex-col sm:flex-row justify-between sm:items-center p-2 rounded-lg hover:bg-gray-100">
                        <div>
                            <span class="text-gray-800 truncate" title="${file.name}">${file.name}</span>
                            <span class="text-xs text-gray-500 ml-2">(by ${file.owner})</span>
                        </div>
                        <div class="flex-shrink-0 flex items-center space-x-2 mt-2 sm:mt-0">
                            <!-- MODIFIED: v3.27 - Adjusted padding and text size -->
                            <button class="preview-audio-btn px-3 py-1 text-sm bg-gray-200 rounded-lg hover:bg-gray-300" data-url="${file.url}" aria-label="Play">&#9654;</button>
                            <!-- Admins can delete public files -->
                            <button class="delete-audio-btn admin-only text-xs px-2 py-1 bg-red-500 text-white rounded-lg hover:bg-red-600" data-path="${file.path}" data-url="${file.url}">Delete</button>
                        </div>
                    </div>
                `).join('');
            }
        }
        
        function updateSoundDropdowns() {
            // --- MODIFIED: v3.43 ---
            // This function combines the v3.42 list of all dropdowns
            // with the v2.24 (working) logic of using `file.url` as the
            // value for the options. This is the other half of the fix.
            
            const selects = [
                // This is the full list of selects from v3.42
                { el: personalSoundInput, myGroup: 'personal-my-sounds-optgroup', sharedGroup: 'personal-shared-sounds-optgroup' },
                { el: sharedSoundInput, myGroup: 'shared-my-sounds-optgroup', sharedGroup: 'shared-shared-sounds-optgroup' },
                { el: multiBellSoundInput, myGroup: 'multi-my-sounds-optgroup', sharedGroup: 'multi-shared-sounds-optgroup' },
                { el: editBellSoundInput, myGroup: 'edit-my-sounds-optgroup', sharedGroup: 'edit-shared-sounds-optgroup' },
                { el: changeSoundSelect, myGroup: 'change-my-sounds-optgroup', sharedGroup: 'change-shared-sounds-optgroup' }, 
                { el: quickBellSoundSelect, myGroup: 'quick-my-sounds-optgroup', sharedGroup: 'quick-shared-sounds-optgroup' } 
            ];
        
            // Create options HTML
            // --- THIS IS THE FIX from v2.24 ---
            // The value *must* be the full file.url, not the file.path.
            const mySoundsHtml = userAudioFiles.map(file => `<option value="${file.url}">${file.name}</option>`).join('');
            const sharedSoundsHtml = sharedAudioFiles.map(file => `<option value="${file.url}">${file.name}</option>`).join('');
        
            // Update all dropdowns
            selects.forEach(item => {
                if (!item.el) return; // Guard clause
                const myGroup = item.el.querySelector(`#${item.myGroup}`);
                const sharedGroup = item.el.querySelector(`#${item.sharedGroup}`);
                
                if (myGroup) {
                    myGroup.innerHTML = mySoundsHtml;
                    // Show/hide based on content
                    myGroup.style.display = mySoundsHtml ? 'block' : 'none';
                }
                if (sharedGroup) {
                    sharedGroup.innerHTML = sharedSoundsHtml;
                    // Show/hide based on content
                    sharedGroup.style.display = sharedSoundsHtml ? 'block' : 'none';
                }
            });
        }
        
        // NEW: Helper function to find all bells using a specific sound URL
        function findBellsUsingSound(url) {
            let bells = [];
            // Check custom bells
            // MODIFIED: v3.03 - Check all personal schedules
            allPersonalSchedules.forEach(schedule => {
                schedule.bells.forEach(bell => {
                    if (bell.sound === url) {
                        bells.push({ scheduleName: schedule.name, bellName: bell.name });
                    }
                });
            });

            // Check all shared schedules
            allSchedules.forEach(schedule => {
                schedule.bells.forEach(bell => {
                    if (bell.sound === url) {
                        bells.push({ scheduleName: schedule.name, bellName: bell.name });
                    }
                });
            });
            return bells;
        }

        // NEW: Helper function to update all bells using a specific sound URL
        async function updateBellsUsingSound(url) {
            const defaultSound = 'ellisBell.mp3';
            // DELETED: v3.03 - customChanged logic
            
            // 1. Update Custom Bells (Local)
            // MODIFIED: v3.03 - Update all personal schedules in Firestore
            const personalBatch = writeBatch(db);
            let personalSchedulesToUpdate = 0;
            if (!isUserAnonymous && userId) {
                allPersonalSchedules.forEach(schedule => {
                    let scheduleNeedsUpdate = false;
                    const updatedBells = schedule.bells.map(bell => {
                        if (bell.sound === url) {
                            scheduleNeedsUpdate = true;
                            return { ...bell, sound: defaultSound };
                        }
                        return bell;
                    });
                    if (scheduleNeedsUpdate) {
                        personalSchedulesToUpdate++;
                        const docRef = doc(db, 'artifacts', appId, 'users', userId, 'personal_schedules', schedule.id);
                        personalBatch.update(docRef, { bells: updatedBells });
                    }
                });
            }
            if (personalSchedulesToUpdate > 0) {
                console.log(`Updating ${personalSchedulesToUpdate} personal schedules...`);
                await personalBatch.commit();
                // MODIFIED: v3.09 - No longer need to call loadPersonalSchedules()
                // The listener will pick up the change.
            }
            

            // 2. Update Shared Schedules (Firestore)
            const batch = writeBatch(db);
            let schedulesToUpdate = 0;
            
            allSchedules.forEach(schedule => {
                let scheduleNeedsUpdate = false;
                const updatedBells = schedule.bells.map(bell => {
                    if (bell.sound === url) {
                        scheduleNeedsUpdate = true;
                        return { ...bell, sound: defaultSound };
                    }
                    return bell;
                });

                if (scheduleNeedsUpdate) {
                    schedulesToUpdate++;
                    const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'schedules', schedule.id);
                    batch.update(docRef, { bells: updatedBells });
                }
            });

            if (schedulesToUpdate > 0) {
                console.log(`Updating ${schedulesToUpdate} shared schedules...`);
                await batch.commit();
                // MODIFIED: v3.24 - Removed loadSharedSchedules()
            } else {
                console.log("No shared schedules needed updating.");
            }
        }

        async function handleAudioListClick(e) {
            const target = e.target;
        
            // Handle Preview
            if (target.classList.contains('preview-audio-btn')) {
                const url = target.dataset.url;
                if (url) {
                    playBell(url);
                }
            }
            
            // Handle Delete
            if (target.classList.contains('delete-audio-btn')) {
                const path = target.dataset.path;
                const url = target.dataset.url; // NEW: Get URL
                if (!path || !url) return;
                
                // NEW: Use custom modal instead of confirm()
                audioToDelete = { path, url }; // Store info
                
                const affectedBells = findBellsUsingSound(url);
                
                if (affectedBells.length > 0) {
                    confirmDeleteAudioText.textContent = "This audio file is used in the following bells. Deleting it will reset them to 'Ellis Bell'. Are you sure?";
                    confirmDeleteAudioList.innerHTML = affectedBells.map(b => `<li class="text-sm"><b>${b.scheduleName}:</b> ${b.bellName}</li>`).join('');
                    confirmDeleteAudioList.classList.remove('hidden');
                } else {
                    confirmDeleteAudioText.textContent = "Are you sure you want to delete this audio file? This cannot be undone.";
                    confirmDeleteAudioList.innerHTML = '';
                    confirmDeleteAudioList.classList.add('hidden');
                }
                confirmDeleteAudioModal.classList.remove('hidden');
            }
            
            // MODIFIED: Handle Make Public (Admin) button click
            if (target.classList.contains('make-public-btn')) {
                
                // *** START OF REPLACEMENT BLOCK ***
                
                // *** NEW CLIENT-SIDE ADMIN CHECK ***
                if (!document.body.classList.contains('admin-mode')) {
                    console.error("Client-side block: Non-admin user attempted to make file public.");
                    // We rely on the button being hidden, but this is the ultimate safeguard.
                    return; 
                }
                
                const sourcePath = target.dataset.path;
                const fileName = target.dataset.name;
                const destPath = `sounds/public/${fileName}`;
                
                // Copy file from user folder to public folder
                target.disabled = true;
                audioUploadStatus.textContent = `Publishing ${fileName}...`;
                audioUploadStatus.classList.remove('hidden');
                try {
                    const sourceRef = ref(storage, sourcePath);
                    const destRef = ref(storage, destPath);
                    
                    // Get metadata from source to copy it
                    const metadata = await getMetadata(sourceRef);
                    
                    // Get the file's bytes directly from storage
                    const bytes = await getBytes(sourceRef);
                    
                    // Create the new metadata for the public file
                    const publicMetadata = { 
                        contentType: metadata.contentType, // <-- THE FIX
                        customMetadata: metadata.customMetadata || { 'owner': userId, 'ownerEmail': auth.currentUser.email || 'unknown' } 
                    };
                    
                    // Upload the bytes data to the new public location
                    await uploadBytes(destRef, bytes, publicMetadata);
                    
                    audioUploadStatus.textContent = `${fileName} is now public.`;
                    await loadAllAudioFiles();
                    setTimeout(() => audioUploadStatus.classList.add('hidden'), 3000);
        
                } catch(error) {
                    console.error("Failed to make file public:", error);
                    audioUploadStatus.textContent = `Error: ${error.message}`;
                    target.disabled = false;
                }
        
                // *** END OF REPLACEMENT BLOCK ***
        
            }
        }

        // NEW: Function to execute the audio deletion
        async function confirmDeleteAudio() {
            if (!audioToDelete) return;

            // *** NEW CLIENT-SIDE ADMIN CHECK (for shared file deletion) ***
            // If the path is public AND the user is not in admin mode, block.
            // Note: Users can still delete their private files, which is fine.
            if (audioToDelete.path.startsWith('sounds/public') && !document.body.classList.contains('admin-mode')) {
                console.error("Client-side block: Non-admin user attempted to delete shared file.");
                // This message will be hidden by the final block, so no need for a visible message here.
                return; 
            }

            const { path, url } = audioToDelete;

            try {
                audioUploadStatus.textContent = "Deleting file...";
                audioUploadStatus.classList.remove('hidden');
                
                const fileRef = ref(storage, path);
                await deleteObject(fileRef);

                // NEW: v3.26 - Immediately clear the cached synth for this URL
                if (synths[url]) {
                    delete synths[url];
                    console.log("Cleared deleted audio from cache:", url);
                }
                
                // NEW: v3.26 - Immediately reset Quick Bell if it was using this sound
                if (quickBellSound === url) {
                    quickBellSound = 'ellisBell.mp3';
                    if (quickBellSoundSelect) { // Check if select is rendered
                        quickBellSoundSelect.value = 'ellisBell.mp3';
                    }
                    console.log("Reset Quick Bell sound from deleted file.");
                }
                
                audioUploadStatus.textContent = "File deleted. Updating schedules...";
                
                // Now update all bells that used this sound
                await updateBellsUsingSound(url);
                
                audioUploadStatus.textContent = "File deleted and schedules updated.";
                await loadAllAudioFiles(); // Refresh lists
            
            } catch (error) {
                console.error("Failed to delete file:", error);
                audioUploadStatus.textContent = `Error: ${error.message}`;
            } finally {
                confirmDeleteAudioModal.classList.add('hidden');
                audioToDelete = null;
                setTimeout(() => audioUploadStatus.classList.add('hidden'), 3000);
            }
        }


        // --- Init and Event Listeners ---
        function init() {
            initFirebase(); 
            loadMutedBells(); 
            loadSoundOverrides(); // NEW: Load sound overrides

            // Auth buttons
            googleStartBtn.addEventListener('click', signInWithGoogle);
            anonymousStartBtn.addEventListener('click', signInAnon);
            
            // Audio start button
            startAudioBtn.addEventListener('click', () => {
                startAudio().then(() => {
                    audioOverlay.classList.add('hidden');
                }).catch(e => {
                    console.error("Manual audio start failed:", e);
                });
            });

            // NEW: v3.09 - Add click-to-refresh for Audio Manager
            const audioManagerHeader = document.querySelector('#audio-manager-panel h2');
            if (audioManagerHeader) {
                audioManagerHeader.addEventListener('click', () => {
                    console.log("User clicked audio manager header, refreshing file lists...");
                    audioUploadStatus.textContent = "Refreshing file lists...";
                    audioUploadStatus.classList.remove('hidden');
                    loadAllAudioFiles().then(() => {
                        setTimeout(() => audioUploadStatus.classList.add('hidden'), 1500);
                    });
                });
            }

            scheduleSelector.addEventListener('change', () => setActiveSchedule(scheduleSelector.value));
            adminToggleBtn.addEventListener('click', toggleAdminMode);

            // Forms
            addPersonalBellForm.addEventListener('submit', handleAddPersonalBell); // MODIFIED: v3.03
            addSharedBellForm.addEventListener('submit', handleAddSharedBell);
            createScheduleForm.addEventListener('submit', handleCreateSchedule);

            // Modals (Delete Schedule)
            deleteScheduleBtn.addEventListener('click', handleDeleteSchedule);
            deleteConfirmBtn.addEventListener('click', confirmDeleteSchedule);
            deleteCancelBtn.addEventListener('click', () => confirmDeleteModal.classList.add('hidden'));

            // NEW: v3.03 - Modals (Create/Delete Personal Schedule)
            createPersonalScheduleBtn.addEventListener('click', () => {
                createPersonalScheduleModal.classList.remove('hidden');
            });
            createPersonalScheduleCancelBtn.addEventListener('click', () => {
                createPersonalScheduleModal.classList.add('hidden');
                createPersonalScheduleForm.reset();
            });
            createPersonalScheduleForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const name = newPersonalScheduleNameInput.value.trim();
                if (!name) return;

                createPersonalScheduleStatus.textContent = "Creating...";
                createPersonalScheduleStatus.classList.remove('hidden');
                
                let newSchedule;
                
                // v3.05: Check if we are duplicating or copying
                if (activePersonalScheduleId) {
                    // DUPLICATING
                    const scheduleToDupe = allPersonalSchedules.find(s => s.id === activePersonalScheduleId);
                    if (!scheduleToDupe) {
                         createPersonalScheduleStatus.textContent = "Error: Source schedule not found.";
                         return;
                    }
                    newSchedule = {
                        name: name,
                        baseScheduleId: scheduleToDupe.baseScheduleId, // Use the dupe's base
                        bells: [...scheduleToDupe.bells] // CRITICAL: new array copy of bells
                    };
                } else if (activeBaseScheduleId) {
                    // COPYING (existing logic)
                    newSchedule = {
                        name: name,
                        baseScheduleId: activeBaseScheduleId,
                        bells: [] // Starts empty
                    };
                } else {
                    createPersonalScheduleStatus.textContent = "Error: No base schedule selected.";
                    return; // No schedule active
                }

                try {
                    const personalSchedulesRef = collection(db, 'artifacts', appId, 'users', userId, 'personal_schedules');
                    const newDocRef = await addDoc(personalSchedulesRef, newSchedule);
                    
                    // MODIFIED: v3.09 - No longer need to call loadPersonalSchedules()
                    // The listener will pick it up.
                    
                    // Automatically select the new schedule
                    scheduleSelector.value = `personal-${newDocRef.id}`;
                    setActiveSchedule(scheduleSelector.value);

                    createPersonalScheduleModal.classList.add('hidden');
                    createPersonalScheduleForm.reset();
                } catch (error) {
                    console.error("Error creating personal schedule:", error);
                    createPersonalScheduleStatus.textContent = "Error creating schedule.";
                } finally {
                    setTimeout(() => createPersonalScheduleStatus.classList.add('hidden'), 2000);
                }
            });

            deletePersonalScheduleBtn.addEventListener('click', () => {
                if (!activePersonalScheduleId) return;
                const schedule = allPersonalSchedules.find(s => s.id === activePersonalScheduleId);
                if (!schedule) return;
                
                confirmDeletePersonalText.textContent = `Are you sure you want to delete "${schedule.name}"? This cannot be undone.`;
                confirmDeletePersonalModal.classList.remove('hidden');
            });
            deletePersonalCancelBtn.addEventListener('click', () => confirmDeletePersonalModal.classList.add('hidden'));
            deletePersonalConfirmBtn.addEventListener('click', async () => {
                if (!activePersonalScheduleId) return;
                
                const docRef = doc(db, 'artifacts', appId, 'users', userId, 'personal_schedules', activePersonalScheduleId);
                try {
                    await deleteDoc(docRef);
                    console.log("Personal schedule deleted:", activePersonalScheduleId);
                    // MODIFIED: v3.09 - No longer need to call loadPersonalSchedules()
                    // The listener will pick up the deletion and renderScheduleSelector will fix the view.
                } catch (error) {
                    console.error("Error deleting personal schedule:", error);
                }
                confirmDeletePersonalModal.classList.add('hidden');
            });
            
            // NEW: v3.05 - Manager Listeners
            renamePersonalScheduleBtn.addEventListener('click', handleRenamePersonalSchedule);
            backupPersonalScheduleBtn.addEventListener('click', handleBackupPersonalSchedule);
            restorePersonalScheduleBtn.addEventListener('click', () => restoreFileInput.click());
            restoreFileInput.addEventListener('change', handleRestoreFileSelect);
            restoreConfirmBtn.addEventListener('click', confirmRestorePersonalSchedule);
            restoreCancelBtn.addEventListener('click', () => {
                confirmRestoreModal.classList.add('hidden');
                pendingRestoreData = null;
            });
            
            // NEW: v3.26 - Rename Modal Listeners
            renamePersonalScheduleForm.addEventListener('submit', handleRenamePersonalScheduleSubmit);
            renamePersonalCancelBtn.addEventListener('click', () => {
                renamePersonalScheduleModal.classList.add('hidden');
                renamePersonalScheduleStatus.classList.add('hidden');
            });


            // Modals (Delete Bell)
            deleteBellConfirmBtn.addEventListener('click', confirmDeleteBell);
            deleteBellCancelBtn.addEventListener('click', () => {
                confirmDeleteBellModal.classList.add('hidden');
                bellToDelete = null;
            });

            // NEW: Modals (Delete Audio)
            deleteAudioConfirmBtn.addEventListener('click', confirmDeleteAudio);
            deleteAudioCancelBtn.addEventListener('click', () => {
                confirmDeleteAudioModal.classList.add('hidden');
                audioToDelete = null;
            });

            // NEW: Modals (Nearby Bell - Custom Only)
            nearbyBellCancelBtn.addEventListener('click', closeNearbyBellModal);
            // MODIFIED: v3.25 - Changed listener
            nearbyBellConfirmBtn.addEventListener('click', confirmPendingPersonalBellAction);

            // NEW: v3.02 Scenario 1 (Internal Conflict) Listeners
            internalConflictCancelBtn.addEventListener('click', closeAllConflictModals);
            internalConflictEditBtn.addEventListener('click', () => {
                // This is the "Edit Existing Bell" button
                if (!currentInternalConflict) return;
                
                // Get the conflicting bell data
                const { time, name, sound } = currentInternalConflict;
                
                // Close the warning modals
                closeAllConflictModals(); 
                
                // Open the edit modal with the conflicting bell's data
                handleEditBellClick(time, name, sound, 'shared');
                
                // Note: 'pendingSharedBell' (the new bell) is discarded, as requested.
            });
            internalConflictConfirmBtn.addEventListener('click', () => {
                // Show Step 2
                internalConflictWarningModal.classList.add('hidden');
                
                const newTime = formatTime12Hour(pendingSharedBell.time, true); // v3.22
                const existing = `${currentInternalConflict.name} at ${formatTime12Hour(currentInternalConflict.time, true)}`; // v3.22
                const diff = Math.abs(timeToSeconds(pendingSharedBell.time) - timeToSeconds(currentInternalConflict.time));

                internalConflictFinalNewTime.textContent = newTime;
                internalConflictFinalExisting.textContent = existing;
                internalConflictFinalDiff.textContent = diff;
                
                internalConflictConfirmModal.classList.remove('hidden');
            });
            internalConflictFinalCancelBtn.addEventListener('click', closeAllConflictModals);
            internalConflictFinalCreateBtn.addEventListener('click', () => {
                // This is the "Yes, Create This Bell" button
                addPendingBellToCurrentSchedule();
            });

            // NEW: v3.02 Scenario 2 (External Conflict) Listeners
            externalConflictModal.addEventListener('change', (e) => {
                if (e.target.classList.contains('external-conflict-check')) {
                    handleExternalConflictCheckboxChange();
                }
            });
            externalConflictCancelBtn.addEventListener('click', closeAllConflictModals);
            externalConflictKeepBtn.addEventListener('click', () => handleExternalConflictResolution('keep'));
            externalConflictMatchBtn.addEventListener('click', () => handleExternalConflictResolution('match'));
            externalConflictCreateAndMatchBtn.addEventListener('click', () => handleExternalConflictResolution('create_and_match'));


            // NEW: Quick Bell Listeners
            quickBellControls.addEventListener('click', (e) => {
                if (e.target.matches('.quick-bell-btn')) {
                    const minutes = parseInt(e.target.dataset.minutes, 10);
                    startQuickBell(minutes);
                }
            });
            quickBellSoundSelect.addEventListener('change', () => {
                quickBellSound = quickBellSoundSelect.value;
            });

            // NEW: Modals (Change Sound)
            changeSoundForm.addEventListener('submit', handleChangeSoundSubmit);
            changeSoundCancelBtn.addEventListener('click', closeChangeSoundModal);
            // NEW: v3.19 - Add play button listener
            previewChangeSoundBtn.addEventListener('click', () => playBell(changeSoundSelect.value));
            
            // Modals (Multi-Add)
            showAddBellModalBtn.addEventListener('click', showMultiAddModal);
            multiAddBellForm.addEventListener('submit', handleMultiAddSubmit);
            multiAddCancelBtn.addEventListener('click', () => {
                addBellModal.classList.add('hidden');
                multiAddBellForm.reset();
                multiBellSoundInput.value = 'ellisBell.mp3'; 
                multiAddStatus.classList.add('hidden');
            });
           multiSelectAllBtn.addEventListener('click', () => {
               document.querySelectorAll('.multi-schedule-check').forEach(cb => cb.checked = true);
           });
           multiSelectNoneBtn.addEventListener('click', () => {
               document.querySelectorAll('.multi-schedule-check').forEach(cb => cb.checked = false);
           });
            
            // Modals (Edit Bell)
            editBellForm.addEventListener('submit', handleEditBellSubmit);
            editBellCancelBtn.addEventListener('click', closeEditBellModal);
            
            // Modals (Linked Edit)
            linkedEditCancel.addEventListener('click', closeLinkedEditModal);
            linkedEditThisOnly.addEventListener('click', () => handleLinkedEdit(false));
            linkedEditApply.addEventListener('click', () => handleLinkedEdit(true));

            signOutBtn.addEventListener('click', signOutUser);

            // Sound previews
            previewPersonalSoundBtn.addEventListener('click', () => playBell(personalSoundInput.value)); // MODIFIED: v3.03
            previewSharedSoundBtn.addEventListener('click', () => playBell(sharedSoundInput.value));
            
            // Event delegation
            combinedBellListElement.addEventListener('click', handleBellListClick);
            
            // Mute All / Unmute All
            const muteAllListBtn = document.getElementById('mute-all-list-btn');
            const unmuteAllListBtn = document.getElementById('unmute-all-list-btn');
            muteAllListBtn.addEventListener('click', () => {
                // MODIFIED: v3.03
                const allBells = [...localSchedule, ...personalBells];
                allBells.forEach(bell => {
                    const bellId = getBellId(bell);
                    if(bellId) mutedBellIds.add(bellId);
                });
                saveMutedBells();
                renderCombinedList();
                updateClock();
            });
            unmuteAllListBtn.addEventListener('click', () => {
                mutedBellIds.clear();
                saveMutedBells();
                renderCombinedList();
                updateClock();
            });

            // Import/Export
            exportSchedulesBtn.addEventListener('click', handleExportSchedules);
            importSchedulesBtn.addEventListener('click', handleImportSchedules);
            importFileInput.addEventListener('change', handleFileInputChange);

            // NEW: Audio Manager Listeners
            audioUploadInput.addEventListener('change', handleFileSelected);
            audioUploadBtn.addEventListener('click', handleAudioUpload);
            // Use event delegation for the dynamic audio lists
            document.getElementById('audio-manager-panel').addEventListener('click', handleAudioListClick);

            // DELETED: v3.03 - loadCustomBells()
            // loadCustomBells();
        }

        // --- Start the App ---
        init();
        // --- NEW in 3.46: App Cleanup Listener (Fix for Safari CORS/Fetch Errors on Refresh) ---
        window.addEventListener('beforeunload', () => {
            try {
                // NEW in 3.47: Stop keep-alive oscillator
                if (keepAliveOscillator) {
                    keepAliveOscillator.stop();
                    keepAliveOscillator.dispose();
                    keepAliveOscillator = null;
                }

                // NEW in 3.48: Stop the alert interval
                if (oscillatorAlertInterval) {
                    clearInterval(oscillatorAlertInterval);
                    oscillatorAlertInterval = null;
                }
                
                // If the Firebase app is initialized, ensure we delete it on page unload
                // to prevent stale connections/tokens causing CORS/Fetch errors on next load.
                if (auth && auth.app) {
                    auth.app.delete();
                    console.log("Cleaned up Firebase app instance on page unload.");
                }
            } catch (e) {
                // Suppress errors during unload
                console.warn("Error during app cleanup:", e);
            }
        });
    </script>
</body>
</html>

<!--
HOW TO ADD A NEW ADMIN:

1.  Ask the new admin to visit this web app and sign in with their Google account.
2.  Have them find their "User ID" in the footer of this page (it looks like a long string of letters and numbers).
3.  Have them send you their User ID.
4.  Go to your Firebase Console: https://console.firebase.google.com/
5.  Select your project: 'ellisbell-c185c'
6.  Navigate to the Firestore Database: (Build -> Firestore Database)
7.  Follow this path in the data viewer:
    artifacts -> 1:441560045695:web:94e51a006663404b8f474a -> public -> data -> admins
    (If the 'admins' collection doesn't exist under 'data', you will need to create it by clicking "+ Start collection" and naming it 'admins').
8.  Click "+ Add document".
9.  In the "Document ID" field, paste the new admin's User ID.
10. In the "Fields" section, add a field:
    * Field: email
    * Type: string
    * Value: (The new admin's email address)
11. Click "Save".

The new admin will have admin privileges (including the "Make Public" button) the next time they refresh the app.
-->

<!-- MODIFIED: Version Bump -->
<!-- Version 3.49 -->
